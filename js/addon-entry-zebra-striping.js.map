{"version":3,"file":"js/addon-entry-zebra-striping.js","sources":["webpack://GUI/./src/addons/addons/zebra-striping/userstyle.css","webpack://GUI/./src/addons/addons/zebra-striping/_runtime_entry.js","webpack://GUI/./src/addons/addons/zebra-striping/userscript.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \":root {\\n  --zebraStriping-percent: calc(var(--zebraStriping-shadeNumber) * var(--zebraStriping-intensity) / 100);\\n  --zebraStriping-bright: calc(1 + var(--zebraStriping-percent));\\n  --zebraStriping-saturate: calc(1 - var(--zebraStriping-percent));\\n  --zebraStriping-filter: brightness(var(--zebraStriping-bright)) saturate(var(--zebraStriping-saturate));\\n  /* \\\"Temporary\\\" value, gets replaced by userscript */\\n  --zebraStriping-replacementGlow: url(#blocklyReplacementGlowFilter);\\n}\\n\\n.sa-zebra-stripe {\\n  filter: var(--zebraStriping-filter);\\n}\\n\\n.sa-zebra-stripe[filter*=\\\"#blocklyReplacementGlowFilter\\\"] {\\n  filter: var(--zebraStriping-filter) var(--zebraStriping-replacementGlow);\\n}\\n\\n/* editor-stepping and debugger compatibility */\\n/* this is pretty horrible */\\n.sa-zebra-stripe[style*=\\\"#sa_glower_filter0\\\"] {\\n  /* !important because editor-stepping Highlighter uses inline styles */\\n  filter: var(--zebraStriping-filter) url(\\\"#sa_glower_filter0\\\") !important;\\n}\\n.sa-zebra-stripe[style*=\\\"#sa_glower_filter1\\\"] {\\n  filter: var(--zebraStriping-filter) url(\\\"#sa_glower_filter1\\\") !important;\\n}\\n\", \"\"]);\n\n// exports\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userstyle.css\": _css,\n};\n","export default async function ({ addon, msg, console }) {\n  const vm = addon.tab.traps.vm;\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n\n  const originalRender = ScratchBlocks.BlockSvg.prototype.render;\n  ScratchBlocks.BlockSvg.prototype.render = function (opt_bubble) {\n    // Any changes that affect block striping should bubble to the top block of the script.\n    // The top block of the script is responsible for striping all of its children.\n    // This way stripes are computed exactly once.\n    if (!this.isInFlyout && !this.isShadow() && this.getParent() === null) {\n      const stripeState = new Map();\n      // Conveniently getDescendants() returns blocks in an order such that each block's\n      // parent will always come before that block (except the first block which has no\n      // parent).\n      for (const block of this.getDescendants()) {\n        const parent = block.getSurroundParent();\n\n        let isStriped = false;\n        if (parent) {\n          if (block.isShadow()) {\n            isStriped = !!stripeState.get(parent);\n          } else if (parent.getColour() === block.getColour()) {\n            isStriped = !stripeState.get(parent);\n          }\n        }\n        stripeState.set(block, isStriped);\n\n        const elements = [block.svgPath_];\n        for (const input of block.inputList) {\n          if (input.outlinePath) {\n            elements.push(input.outlinePath);\n          }\n          for (const field of input.fieldRow) {\n            if (field.fieldGroup_) {\n              elements.push(field.fieldGroup_);\n            }\n          }\n        }\n        for (const el of elements) {\n          el.classList.toggle(\"sa-zebra-stripe\", isStriped);\n        }\n      }\n    }\n    return originalRender.call(this, opt_bubble);\n  };\n\n  if (vm.editingTarget) {\n    vm.emitWorkspaceUpdate();\n  }\n\n  // The replacement glow filter's ID is randomly generated and changes\n  // when the workspace is reloaded (which includes loading the page and\n  // seeing the project page then seeing inside).\n  // As we need to stack the filter with the striping filter in the\n  // userstyle, we need to use the userscript to get the filter's ID\n  // and set a CSS variable on the document's root.\n  while (true) {\n    const replacementGlowEl = await addon.tab.waitForElement('filter[id*=\"blocklyReplacementGlowFilter\"]', {\n      markAsSeen: true,\n      reduxEvents: [\"scratch-gui/mode/SET_PLAYER\", \"fontsLoaded/SET_FONTS_LOADED\", \"scratch-gui/locales/SELECT_LOCALE\"],\n      reduxCondition: (state) => !state.scratchGui.mode.isPlayerOnly,\n    });\n    document.documentElement.style.setProperty(\"--zebraStriping-replacementGlow\", `url(#${replacementGlowEl.id})`);\n  }\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;;A","sourceRoot":""}