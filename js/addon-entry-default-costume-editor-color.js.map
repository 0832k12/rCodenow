{"version":3,"file":"js/addon-entry-default-costume-editor-color.js","sources":["webpack://GUI/./src/addons/addons/default-costume-editor-color/_runtime_entry.js","webpack://GUI/./src/addons/addons/default-costume-editor-color/userscript.js"],"sourcesContent":["/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async function ({ addon, console, msg }) {\n  // We don\"t *need* to wait for the costume editor to be opened, but redux updates take a non-zero\n  // amount of CPU time so let's delay that for as long as possible.\n  await addon.tab.traps.getPaper();\n\n  const hexComponent = (str) => Math.round(+str).toString(16).toUpperCase().padStart(2, \"0\");\n\n  const parseColor = (color) => {\n    if (color === null) {\n      return null;\n    }\n    if (typeof color === \"string\") {\n      // TW natively supports hex color codes with or without transparency\n      if (color.startsWith(\"#\")) {\n        return color.substring(0, 9).toUpperCase();\n      }\n      // Sometimes paper gives us rgb() colors which have to be converted to hex\n      const rgbMatch = color.match(/^rgb\\((\\d+)\\s*,(\\d+)\\s*,(\\d+)\\)$/);\n      if (rgbMatch) {\n        const [_, r, g, b] = rgbMatch;\n        return `#${hexComponent(r)}${hexComponent(g)}${hexComponent(b)}`;\n      }\n      // It can also give us rgba() colors\n      const rgbaMatch = color.match(/^rgba\\((\\d+)\\s*,(\\d+)\\s*,(\\d+),([\\d.]+)\\)$/);\n      if (rgbaMatch) {\n        const [_, r, g, b, a] = rgbaMatch;\n        return `#${hexComponent(r)}${hexComponent(g)}${hexComponent(b)}${hexComponent(a * 255)}`;\n      }\n    }\n    console.log(\"Could not normalize color\", color);\n    return null;\n  };\n\n  const parseColorStyleColor = (color) => {\n    if (color === MIXED) return MIXED;\n    return parseColor(color);\n  };\n\n  // Special value Scratch uses as color when objects with different colors are selected\n  // https://github.com/LLK/scratch-paint/blob/6733e20b56f52d139f9885952a57c7da012a542f/src/helper/style-path.js#L10\n  const MIXED = \"scratch-paint/style-path/mixed\";\n\n  const SCRATCH_DEFAULT_FILL = parseColor(\"#9966FF\");\n  const SCRATCH_DEFAULT_STROKE = parseColor(\"#000000\");\n\n  const TOOL_INFO = Object.assign(Object.create(null), {\n    // Tool names and gradient info defined in https://github.com/LLK/scratch-paint/blob/develop/src/lib/modes.js\n    // Search for activateTool() in matching file in https://github.com/LLK/scratch-paint/tree/develop/src/containers\n    BRUSH: {\n      resetsFill: true,\n    },\n    ERASER: {},\n    LINE: {\n      resetsStroke: true,\n      requiresNonZeroStrokeWidth: true,\n      supportsGradient: true,\n    },\n    FILL: {\n      resetsFill: true,\n      supportsGradient: true,\n    },\n    SELECT: {\n      supportsGradient: true,\n    },\n    RESHAPE: {\n      supportsGradient: true,\n    },\n    OVAL: {\n      resetsFill: true,\n      resetsStroke: true,\n      supportsGradient: true,\n    },\n    RECT: {\n      resetsFill: true,\n      resetsStroke: true,\n      supportsGradient: true,\n    },\n    TEXT: {\n      resetsFill: true,\n      resetsStroke: true,\n    },\n    BIT_BRUSH: {\n      resetsFill: true,\n    },\n    BIT_LINE: {\n      resetsFill: true,\n      requiresNonZeroStrokeWidth: true,\n    },\n    BIT_OVAL: {\n      resetsFill: true,\n      resetsStroke: true,\n      supportsGradient: true,\n    },\n    BIT_RECT: {\n      resetsFill: true,\n      resetsStroke: true,\n      supportsGradient: true,\n    },\n    BIT_TEXT: {\n      resetsFill: true,\n      resetsStroke: true,\n    },\n    BIT_FILL: {\n      resetsFill: true,\n      supportsGradient: true,\n    },\n    BIT_ERASER: {},\n    BIT_SELECT: {\n      supportsGradient: true,\n    },\n  });\n\n  const getToolInfo = () => TOOL_INFO[addon.tab.redux.state.scratchPaint.mode];\n\n  class ColorStyleReducerWrapper {\n    constructor(reduxPropertyName, primaryAction, secondaryAction, gradientTypeAction) {\n      this.reduxPropertyName = reduxPropertyName;\n      this.primaryAction = primaryAction;\n      this.secondaryAction = secondaryAction;\n      this.gradientTypeAction = gradientTypeAction;\n    }\n\n    get(state = addon.tab.redux.state) {\n      return state.scratchPaint.color[this.reduxPropertyName];\n    }\n\n    set(newColor) {\n      const state = this.get();\n      const newPrimary = parseColorStyleColor(newColor.primary);\n      if (state.primary !== newPrimary) {\n        addon.tab.redux.dispatch({\n          type: this.primaryAction,\n          color: newPrimary,\n        });\n      }\n      const toolInfo = getToolInfo();\n      const toolSupportsGradient = toolInfo && toolInfo.supportsGradient;\n      if (toolSupportsGradient) {\n        const newSecondary = parseColorStyleColor(newColor.secondary);\n        if (state.secondary !== newSecondary) {\n          addon.tab.redux.dispatch({\n            type: this.secondaryAction,\n            color: newSecondary,\n          });\n        }\n        if (state.gradientType !== newColor.gradientType) {\n          addon.tab.redux.dispatch({\n            type: this.gradientTypeAction,\n            gradientType: newColor.gradientType,\n          });\n        }\n      }\n    }\n  }\n\n  const fillStyle = new ColorStyleReducerWrapper(\n    \"fillColor\",\n    \"scratch-paint/fill-style/CHANGE_FILL_COLOR\",\n    \"scratch-paint/fill-style/CHANGE_FILL_COLOR_2\",\n    \"scratch-paint/fill-style/CHANGE_FILL_GRADIENT_TYPE\"\n  );\n  const strokeStyle = new ColorStyleReducerWrapper(\n    \"strokeColor\",\n    \"scratch-paint/stroke-style/CHANGE_STROKE_COLOR\",\n    \"scratch-paint/stroke-style/CHANGE_STROKE_COLOR_2\",\n    \"scratch-paint/stroke-style/CHANGE_STROKE_GRADIENT_TYPE\"\n  );\n\n  const simpleHexColor = (hex) => ({\n    primary: hex,\n    secondary: null,\n    gradientType: \"SOLID\",\n  });\n\n  let defaultFillColor;\n  let defaultStrokeColor;\n  let defaultStrokeWidth;\n  const setDefaultColorsToSettings = () => {\n    defaultFillColor = simpleHexColor(parseColor(addon.settings.get(\"fill\")));\n    defaultStrokeColor = simpleHexColor(parseColor(addon.settings.get(\"stroke\")));\n    defaultStrokeWidth = addon.settings.get(\"strokeSize\");\n  };\n  setDefaultColorsToSettings();\n\n  const applyFillColor = () => {\n    fillStyle.set(defaultFillColor);\n  };\n  const applyStrokeColor = () => {\n    strokeStyle.set(defaultStrokeColor);\n  };\n  const applyStrokeWidth = (mustBeNonZero) => {\n    let width = defaultStrokeWidth;\n    if (width === 0 && mustBeNonZero) {\n      width = 1;\n    }\n    if (addon.tab.redux.state.scratchPaint.color.strokeWidth !== width) {\n      addon.tab.redux.dispatch({\n        type: \"scratch-paint/stroke-width/CHANGE_STROKE_WIDTH\",\n        strokeWidth: width,\n      });\n    }\n  };\n\n  if (!addon.self.disabled) {\n    applyFillColor();\n    applyStrokeColor();\n    applyStrokeWidth(false);\n  }\n\n  addon.settings.addEventListener(\"change\", () => {\n    if (!addon.settings.get(\"persistence\")) {\n      setDefaultColorsToSettings();\n    }\n  });\n\n  const isValidColorToPersist = (color) => color.primary !== null && color.primary !== MIXED;\n\n  let activatingTool = false;\n  addon.tab.redux.initialize();\n  addon.tab.redux.addEventListener(\"statechanged\", ({ detail }) => {\n    if (addon.self.disabled) {\n      return;\n    }\n    const action = detail.action;\n\n    if (!activatingTool && addon.settings.get(\"persistence\")) {\n      // We always want to check for changes instead of filtering to just certain actions because quite a few\n      // actions can change these.\n      const newFill = fillStyle.get();\n      if (fillStyle.get(detail.prev) !== newFill && isValidColorToPersist(newFill)) {\n        defaultFillColor = newFill;\n      }\n      const newStroke = strokeStyle.get();\n      if (strokeStyle.get(detail.prev) !== newStroke && isValidColorToPersist(newStroke)) {\n        defaultStrokeColor = newStroke;\n      }\n\n      const newStrokeWidth = detail.next.scratchPaint.color.strokeWidth;\n      if (typeof newStrokeWidth === \"number\") {\n        defaultStrokeWidth = newStrokeWidth;\n      }\n    }\n\n    if (action.type === \"scratch-paint/modes/CHANGE_MODE\") {\n      activatingTool = true;\n      queueMicrotask(() => {\n        activatingTool = false;\n        if (addon.settings.get(\"persistence\")) {\n          // In persistence, we always want to re-apply the previous stroke and fill.\n          const toolInfo = getToolInfo();\n          if (!toolInfo) {\n            console.warn(\"unknown tool\", addon.tab.redux.state.scratchPaint.mode);\n            return;\n          }\n          if (toolInfo.resetsFill) {\n            applyFillColor();\n          }\n          if (toolInfo.resetsStroke) {\n            applyStrokeWidth(!!toolInfo.requiresNonZeroStrokeWidth);\n            applyStrokeColor();\n          }\n        } else {\n          // In non-persistence, we'll only apply the default colors when Scratch resets them to maintain the same behavior.\n          // We have to do this weird redux trick because we can't modify these constants:\n          // https://github.com/LLK/scratch-paint/blob/6733e20b56f52d139f9885952a57c7da012a542f/src/reducers/fill-style.js#L7\n          // https://github.com/LLK/scratch-paint/blob/6733e20b56f52d139f9885952a57c7da012a542f/src/reducers/stroke-style.js#L7\n          const oldFillColor = fillStyle.get(detail.prev);\n          if (oldFillColor.primary === null || oldFillColor.primary === MIXED) {\n            const newFillColor = fillStyle.get();\n            if (newFillColor.primary === SCRATCH_DEFAULT_FILL) {\n              applyFillColor();\n            }\n          }\n          const oldStrokeColor = strokeStyle.get(detail.prev);\n          if (oldStrokeColor.primary === null || oldStrokeColor.primary === MIXED) {\n            const newStrokeColor = strokeStyle.get();\n            if (newStrokeColor.primary === SCRATCH_DEFAULT_STROKE) {\n              applyStrokeWidth(true);\n              applyStrokeColor();\n            }\n          }\n        }\n      });\n    }\n  });\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AADA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AAIA;AACA;AADA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AADA;AA9DA;AACA;AAkEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAvCA;AACA;AAwCA;AAMA;AACA;AAMA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}