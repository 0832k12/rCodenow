{"version":3,"file":"js/addon-entry-paint-snap.js","sources":["webpack://GUI/./src/addons/addons/paint-snap/userstyle.css","webpack://GUI/./src/addons/addons/paint-snap/icons/decrement.svg","webpack://GUI/./src/addons/addons/paint-snap/icons/increment.svg","webpack://GUI/./src/addons/addons/paint-snap/icons/off.svg","webpack://GUI/./src/addons/addons/paint-snap/icons/on.svg","webpack://GUI/./src/addons/addons/paint-snap/icons/settings.svg","webpack://GUI/./src/addons/addons/paint-snap/icons/snap.svg","webpack://GUI/./src/addons/addons/paint-snap/_runtime_entry.js","webpack://GUI/./src/addons/addons/paint-snap/genScalePoints.js","webpack://GUI/./src/addons/addons/paint-snap/genSnapPoints.js","webpack://GUI/./src/addons/addons/paint-snap/helpers.js","webpack://GUI/./src/addons/addons/paint-snap/state.js","webpack://GUI/./src/addons/addons/paint-snap/ui.js","webpack://GUI/./src/addons/addons/paint-snap/updateScaleTool.js","webpack://GUI/./src/addons/addons/paint-snap/updateSelectTool.js","webpack://GUI/./src/addons/addons/paint-snap/userscript.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-paint-snap-button {\\n  position: relative;\\n}\\n.sa-paint-snap-button:focus-within {\\n  background-color: hsla(0, 100%, 65%, 0.2);\\n}\\n.sa-paint-snap-button[data-enabled=\\\"true\\\"] .sa-paint-snap-image {\\n  filter: brightness(0) invert(1);\\n}\\n.sa-paint-snap-button[data-enabled=\\\"true\\\"] {\\n  background-color: #ff4c4c;\\n}\\n\\n.sa-paint-snap-group {\\n  position: relative;\\n  flex-direction: row;\\n}\\n\\n.sa-paint-snap-settings-wrapper {\\n  position: absolute;\\n  justify-items: center;\\n  left: 50%;\\n  width: 1.95rem;\\n  height: 1.95rem;\\n  display: grid;\\n}\\n\\n.sa-paint-snap-settings {\\n  position: absolute;\\n  bottom: 100%;\\n  /* based on the styles for the color dropdown */\\n  padding: 4px;\\n  border-radius: 4px;\\n  border: 1px solid var(--paint-ui-pane-border, #ddd);\\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\\n  transition-property: bottom, opacity;\\n  transition-duration: 500ms;\\n  transition-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\\n  opacity: 0;\\n  pointer-events: none;\\n  background: var(--ui-primary, white);\\n  min-height: 100%;\\n  min-width: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n}\\n.sa-paint-snap-settings[data-visible=\\\"true\\\"] {\\n  bottom: calc(100% + 22px);\\n  pointer-events: auto;\\n  opacity: 1;\\n}\\n\\n.sa-paint-snap-settings-line {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: baseline;\\n}\\n\\n.sa-paint-snap-settings-input {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  box-sizing: border-box;\\n  text-align: center;\\n  border: 0;\\n  background: transparent;\\n  -moz-appearance: textfield;\\n  border: 0;\\n  outline: 0;\\n}\\n\\n.sa-paint-snap-settings-input::-webkit-outer-spin-button,\\n.sa-paint-snap-settings-input::-webkit-inner-spin-button {\\n  -webkit-appearance: none;\\n  margin: 0;\\n}\\n\\n.sa-paint-snap-settings-tip {\\n  position: absolute;\\n  bottom: 0;\\n  transform: translateY(100%);\\n  right: calc(50% - 7px);\\n}\\n.sa-paint-snap-settings-polygon {\\n  fill: var(--ui-primary, white);\\n  stroke: var(--paint-ui-pane-border, #ddd);\\n}\\n\\n.sa-paint-snap-settings-separator {\\n  flex-grow: 1;\\n  border-bottom: 1px solid currentColor;\\n  margin: 4px;\\n  opacity: 0.25;\\n}\\n\\n.sa-paint-snap-settings-section {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n  align-items: flex-end;\\n  width: 100%;\\n}\\n\\n.sa-paint-snap-settings-section-title {\\n  font-size: 1.2em;\\n  font-weight: 500;\\n  align-self: flex-start;\\n  margin-left: 4px;\\n}\\n\\n.sa-paint-snap-settings-label {\\n  white-space: nowrap;\\n}\\n\\n.sa-paint-snap-image[data-shrink=\\\"true\\\"] {\\n  height: 1em;\\n  width: 1em;\\n}\\n\", \"\"]);\n\n// exports\n","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHdpZHRoPSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDkwKSIgc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUtMTIuNjQyaDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzU3NWU3NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0ibTExLjI1IDQuNzUtNi41IDYuNW0wLTYuNSA2LjUgNi41Ii8+PC9zdmc+\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGw9IiM1NzVlNzUiIGQ9Ik0xMi43MzYgMy45N2EuNzMzLjczMyAwIDAgMSAxLjA0NyAwYy4yODYuMjg5LjI5Ljc1Ni4wMSAxLjA1TDcuODggMTIuMDFhLjczMy43MzMgMCAwIDEtMS4wNjUuMDJMMy4yMTcgOC4zODRhLjc1Ny43NTcgMCAwIDEgMC0xLjA2LjczMy43MzMgMCAwIDEgMS4wNDcgMGwzLjA1MiAzLjA5MyA1LjQtNi40MjVhLjI0Ny4yNDcgMCAwIDEgLjAyLS4wMjJaIi8+PC9zdmc+\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PGNpcmNsZSBjeD0iMTIuNTUiIGN5PSIxMi41NSIgcj0iOS4wNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNTc1ZTc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iNyIvPjxjaXJjbGUgY3g9IjYxLjk0MyIgY3k9IjYxLjQzNiIgcj0iNy41IiBmaWxsPSIjNTc1ZTc1Ii8+PHBhdGggZmlsbD0iIzU3NWU3NSIgZD0ibTUzLjExOSAyNy43NDMtOC4yNjcgOC4yNjZMMzEuNjkgMjIuODQ3bC04LjU3IDguNTczIDEzLjE2IDEzLjE2LTguMjY2IDguMjY2aDI1LjEwNXoiIGNvbG9yPSIjNTc1ZTc1Ii8+PHBhdGggZmlsbD0iIzU3NWU3NSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNDYuMjI3IDEwMGMuNTMtMy4yMDUgMS4yMTktNi4zNzQgMi4xMTItOS40N2wtNC44MDQtMS4zODZjLS45NTQgMy4zMS0xLjY4MyA2LjY2OS0yLjI0IDEwLjA0em0zLjYwMy0xNC4wNjhhNjMuOTM1IDYzLjkzNSAwIDAgMSAzLjkzLTguNzc1bC00LjM5My0yLjM4NmE2OC45MTcgNjguOTE3IDAgMCAwLTQuMjQgOS40NnptNi4zODItMTIuOWMxLjc1My0yLjY5NCAzLjY5LTUuMjQ5IDUuODQtNy41NzhsLTMuNjczLTMuMzkyYy0yLjM3MiAyLjU2OS00LjQ3NCA1LjM1LTYuMzU3IDguMjQxem05LjIzNC0xMC45NDFhNTcuOTUgNTcuOTUgMCAwIDEgNy42MDktNS44MTNsLTIuNzAzLTQuMjA4YTYyLjk0NCA2Mi45NDQgMCAwIDAtOC4yNjYgNi4zMTd6bTExLjc1Mi04LjI2MmE3MS4yNjUgNzEuMjY1IDAgMCAxIDguNzg2LTRsLTEuNzY2LTQuNjc3YTc2LjI0MiA3Ni4yNDIgMCAwIDAtOS40MDEgNC4yODF6bTEzLjM3Mi01LjU3MkE4Ny45MjYgODcuOTI2IDAgMCAxIDEwMCA0NS45MUw5OS4wNTcgNDFhOTIuOTM4IDkyLjkzOCAwIDAgMC05Ljk2NyAyLjQ4eiIgY29sb3I9IiM1NzVlNzUiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgNTEyIDUxMiI+PHBhdGggZmlsbD0iIzU3NWU3NSIgc3Ryb2tlPSIjNTc1ZTc1IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS13aWR0aD0iMzIiIGQ9Ik0xOTEuOTggNDYzLjU4di00OE05MC4xNiA0MjEuNGwzMy45NC0zMy45NG0tNzYuMTItNjcuODhoNDgiLz48cGF0aCBmaWxsPSIjNTc1ZTc1IiBkPSJNNDIyLjIgODkuODJhMTQ0IDE0NCAwIDAgMC0yMDMuNzEtLjA3bC02Ny44OCA2Ny44OCA2Ny44OCA2Ny44OSA2Ny44OC02Ny44OWE0OCA0OCAwIDAgMSA2OC40Ni41OWMxOC4zIDE4LjkyIDE3LjQ4IDQ5LjI0LTEuMTQgNjcuODZsLTY3LjMyIDY3LjMyIDY3Ljg4IDY3Ljg4IDY2LjkxLTY2LjkxYzU2LjM3LTU2LjM3IDU3LjM3LTE0OC4xNSAxLjA0LTIwNC41NVpNODIuNzE5IDIyNS41MTdsNDUuMjU0LTQ1LjI1NCA2Ny44ODMgNjcuODgyTDE1MC42IDI5My40ek0yMTguNDkgMzYxLjI3bDQ1LjI1NC00NS4yNTQgNjcuODgyIDY3Ljg4Mi00NS4yNTUgNDUuMjU1eiIvPjwvc3ZnPg==\"","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nimport _asset from \"!url-loader!./icons/decrement.svg\";\nimport _asset2 from \"!url-loader!./icons/increment.svg\";\nimport _asset3 from \"!url-loader!./icons/off.svg\";\nimport _asset4 from \"!url-loader!./icons/on.svg\";\nimport _asset5 from \"!url-loader!./icons/settings.svg\";\nimport _asset6 from \"!url-loader!./icons/snap.svg\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userstyle.css\": _css,\n  \"icons/decrement.svg\": _asset,\n  \"icons/increment.svg\": _asset2,\n  \"icons/off.svg\": _asset3,\n  \"icons/on.svg\": _asset4,\n  \"icons/settings.svg\": _asset5,\n  \"icons/snap.svg\": _asset6,\n};\n","import { snapFrom, snapTo } from \"./state.js\";\n\nexport default function createScalePoints(paper, lib, objects, sx, sy) {\n  const {\n    view: { CENTER, ART_BOARD_BOUNDS },\n  } = lib;\n\n  const toPoints = {\n    ...(snapTo.pageAxes\n      ? {\n          ...(sx\n            ? {\n                bounds_cx: {\n                  type: \"xcoord\",\n                  value: CENTER.x,\n                },\n              }\n            : {}),\n          ...(sy\n            ? {\n                bounds_cy: {\n                  type: \"ycoord\",\n                  value: CENTER.y,\n                },\n              }\n            : {}),\n        }\n      : {}),\n    ...(snapTo.pageEdges\n      ? {\n          ...(sx\n            ? {\n                bounds_l: {\n                  type: \"xcoord\",\n                  value: ART_BOARD_BOUNDS.left,\n                  clamp: {\n                    min: ART_BOARD_BOUNDS.top,\n                    max: ART_BOARD_BOUNDS.bottom,\n                  },\n                },\n                bounds_r: {\n                  type: \"xcoord\",\n                  value: ART_BOARD_BOUNDS.right,\n                  clamp: {\n                    min: ART_BOARD_BOUNDS.top,\n                    max: ART_BOARD_BOUNDS.bottom,\n                  },\n                },\n              }\n            : {}),\n          ...(sy\n            ? {\n                bounds_t: {\n                  type: \"ycoord\",\n                  value: ART_BOARD_BOUNDS.top,\n                  clamp: {\n                    min: ART_BOARD_BOUNDS.left,\n                    max: ART_BOARD_BOUNDS.right,\n                  },\n                },\n                bounds_b: {\n                  type: \"ycoord\",\n                  value: ART_BOARD_BOUNDS.bottom,\n                  clamp: {\n                    min: ART_BOARD_BOUNDS.left,\n                    max: ART_BOARD_BOUNDS.right,\n                  },\n                },\n              }\n            : {}),\n          ...(sx\n            ? {\n                bounds_w: {\n                  type: \"width\",\n                  value: CENTER.y,\n                  clamp: {\n                    min: ART_BOARD_BOUNDS.left,\n                    max: ART_BOARD_BOUNDS.right,\n                  },\n                },\n              }\n            : {}),\n          ...(sy\n            ? {\n                bounds_h: {\n                  type: \"height\",\n                  value: CENTER.x,\n                  clamp: {\n                    min: ART_BOARD_BOUNDS.bottom,\n                    max: ART_BOARD_BOUNDS.top,\n                  },\n                },\n              }\n            : {}),\n        }\n      : {}),\n    ...(snapTo.objectEdges\n      ? Object.fromEntries(\n          objects\n            .filter((item) => !(item.selected || item.data.isHelperItem))\n            .map((item) =>\n              [\n                sx && [\n                  `item_${item.id}_r`,\n                  {\n                    type: \"xcoord\",\n                    value: item.bounds.right,\n                  },\n                ],\n                sx && [\n                  `item_${item.id}_l`,\n                  {\n                    type: \"xcoord\",\n                    value: item.bounds.left,\n                  },\n                ],\n                sy && [\n                  `item_${item.id}_t`,\n                  {\n                    type: \"ycoord\",\n                    value: item.bounds.top,\n                  },\n                ],\n                sy && [\n                  `item_${item.id}_b`,\n                  {\n                    type: \"ycoord\",\n                    value: item.bounds.bottom,\n                  },\n                ],\n                sx && [\n                  `item_${item.id}_w`,\n                  {\n                    type: \"width\",\n                    value: item.bounds.bottom,\n                    clamp: {\n                      min: item.bounds.left,\n                      max: item.bounds.right,\n                    },\n                  },\n                ],\n                sy && [\n                  `item_${item.id}_h`,\n                  {\n                    type: \"height\",\n                    value: item.bounds.left,\n                    clamp: {\n                      min: item.bounds.bottom,\n                      max: item.bounds.top,\n                    },\n                  },\n                ],\n              ].filter(Boolean)\n            )\n            .flat(1)\n        )\n      : {}),\n    ...(snapTo.objectMidlines\n      ? Object.fromEntries(\n          objects\n            .filter((item) => !(item.selected || item.data.isHelperItem))\n            .map((item) =>\n              [\n                sx && [\n                  `item_${item.id}_cx`,\n                  {\n                    type: \"xcoord\",\n                    value: item.bounds.center.x,\n                  },\n                ],\n                sy && [\n                  `item_${item.id}_cy`,\n                  {\n                    type: \"ycoord\",\n                    value: item.bounds.center.y,\n                  },\n                ],\n              ].filter(Boolean)\n            )\n            .flat(1)\n        )\n      : {}),\n  };\n\n  return toPoints;\n}\n","import { snapFrom, snapTo } from \"./state.js\";\n\nexport default function createSnapPoints(paper, selectionBounds, lib, objects) {\n  const {\n    view: { CENTER, ART_BOARD_BOUNDS },\n  } = lib;\n  const fromPoints = {\n    ...(snapFrom.boxCenter\n      ? {\n          center: selectionBounds.center,\n        }\n      : {}),\n    ...(snapFrom.boxCorners\n      ? {\n          topLeft: selectionBounds.topLeft,\n          topRight: selectionBounds.topRight,\n          bottomLeft: selectionBounds.bottomLeft,\n          bottomRight: selectionBounds.bottomRight,\n        }\n      : {}),\n    ...(snapFrom.boxEdgeMids\n      ? {\n          left: new paper.Point(selectionBounds.left, selectionBounds.center.y),\n          right: new paper.Point(selectionBounds.right, selectionBounds.center.y),\n          top: new paper.Point(selectionBounds.center.x, selectionBounds.top),\n          bottom: new paper.Point(selectionBounds.center.x, selectionBounds.bottom),\n        }\n      : {}),\n  };\n\n  const toPoints = {\n    ...(snapTo.pageCenter\n      ? {\n          bounds_c: {\n            type: \"point\",\n            value: CENTER,\n          },\n        }\n      : {}),\n    ...(snapTo.pageAxes\n      ? {\n          bounds_cx: {\n            type: \"xcoord\",\n            value: CENTER.x,\n          },\n          bounds_cy: {\n            type: \"ycoord\",\n            value: CENTER.y,\n          },\n        }\n      : {}),\n    ...(snapTo.pageEdges\n      ? {\n          bounds_l: {\n            type: \"xcoord\",\n            value: ART_BOARD_BOUNDS.left,\n            clamp: {\n              min: ART_BOARD_BOUNDS.top,\n              max: ART_BOARD_BOUNDS.bottom,\n            },\n          },\n          bounds_r: {\n            type: \"xcoord\",\n            value: ART_BOARD_BOUNDS.right,\n            clamp: {\n              min: ART_BOARD_BOUNDS.top,\n              max: ART_BOARD_BOUNDS.bottom,\n            },\n          },\n          bounds_t: {\n            type: \"ycoord\",\n            value: ART_BOARD_BOUNDS.top,\n            clamp: {\n              min: ART_BOARD_BOUNDS.left,\n              max: ART_BOARD_BOUNDS.right,\n            },\n          },\n          bounds_b: {\n            type: \"ycoord\",\n            value: ART_BOARD_BOUNDS.bottom,\n            clamp: {\n              min: ART_BOARD_BOUNDS.left,\n              max: ART_BOARD_BOUNDS.right,\n            },\n          },\n          bounds_lc: {\n            type: \"point\",\n            value: new paper.Point(ART_BOARD_BOUNDS.left, CENTER.y),\n          },\n          bounds_rc: {\n            type: \"point\",\n            value: new paper.Point(ART_BOARD_BOUNDS.right, CENTER.y),\n          },\n          bounds_tc: {\n            type: \"point\",\n            value: new paper.Point(CENTER.x, ART_BOARD_BOUNDS.top),\n          },\n          bounds_bc: {\n            type: \"point\",\n            value: new paper.Point(CENTER.x, ART_BOARD_BOUNDS.bottom),\n          },\n        }\n      : {}),\n    ...(snapTo.pageCorners\n      ? {\n          bounds_tl: {\n            type: \"point\",\n            value: ART_BOARD_BOUNDS.topLeft,\n          },\n          bounds_tr: {\n            type: \"point\",\n            value: ART_BOARD_BOUNDS.topRight,\n          },\n          bounds_bl: {\n            type: \"point\",\n            value: ART_BOARD_BOUNDS.bottomLeft,\n          },\n          bounds_br: {\n            type: \"point\",\n            value: ART_BOARD_BOUNDS.bottomRight,\n          },\n        }\n      : {}),\n    ...(snapTo.objectEdges\n      ? Object.fromEntries(\n          objects\n            .filter((item) => !(item.selected || item.data.isHelperItem))\n            .map((item) => [\n              [\n                `item_${item.id}_r`,\n                {\n                  type: \"itemSideVert\",\n                  value: item.bounds.right,\n                  clamp: {\n                    min: item.bounds.top,\n                    max: item.bounds.bottom,\n                  },\n                },\n              ],\n              [\n                `item_${item.id}_l`,\n                {\n                  type: \"itemSideVert\",\n                  value: item.bounds.left,\n                  clamp: {\n                    min: item.bounds.top,\n                    max: item.bounds.bottom,\n                  },\n                },\n              ],\n              [\n                `item_${item.id}_t`,\n                {\n                  type: \"itemSideHoriz\",\n                  value: item.bounds.top,\n                  clamp: {\n                    min: item.bounds.left,\n                    max: item.bounds.right,\n                  },\n                },\n              ],\n              [\n                `item_${item.id}_b`,\n                {\n                  type: \"itemSideHoriz\",\n                  value: item.bounds.bottom,\n                  clamp: {\n                    min: item.bounds.left,\n                    max: item.bounds.right,\n                  },\n                },\n              ],\n            ])\n            .flat(1)\n        )\n      : {}),\n    ...(snapTo.objectCenters\n      ? Object.fromEntries(\n          objects\n            .filter((item) => !item.selected)\n            .map((item) => [\n              [\n                `item_${item.id}_c`,\n                {\n                  type: \"point\",\n                  value: item.bounds.center,\n                },\n              ],\n            ])\n            .flat(1)\n        )\n      : {}),\n    ...(snapTo.objectMidlines\n      ? Object.fromEntries(\n          objects\n            .filter((item) => !item.selected)\n            .map((item) => [\n              [\n                `item_${item.id}_cx`,\n                {\n                  type: \"xcoord\",\n                  value: item.bounds.center.x,\n                },\n              ],\n              [\n                `item_${item.id}_cy`,\n                {\n                  type: \"ycoord\",\n                  value: item.bounds.center.y,\n                },\n              ],\n            ])\n            .flat(1)\n        )\n      : {}),\n    ...(snapTo.objectCorners\n      ? Object.fromEntries(\n          objects\n            .filter((item) => !(item.selected || item.data.isHelperItem))\n            .map((item) => [\n              [\n                `item_${item.id}_tl`,\n                {\n                  type: \"point\",\n                  value: item.bounds.topLeft,\n                },\n              ],\n              [\n                `item_${item.id}_tr`,\n                {\n                  type: \"point\",\n                  value: item.bounds.topRight,\n                },\n              ],\n              [\n                `item_${item.id}_bl`,\n                {\n                  type: \"point\",\n                  value: item.bounds.bottomLeft,\n                },\n              ],\n              [\n                `item_${item.id}_br`,\n                {\n                  type: \"point\",\n                  value: item.bounds.bottomRight,\n                },\n              ],\n            ])\n            .flat(1)\n        )\n      : {}),\n  };\n\n  return {\n    from: fromPoints,\n    to: toPoints,\n  };\n}\n","export function loadModules(paper) {\n  // https://github.com/LLK/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/math.js\n\n  const checkPointsClose = function (startPos, eventPoint, threshold) {\n    const xOff = Math.abs(startPos.x - eventPoint.x);\n    const yOff = Math.abs(startPos.y - eventPoint.y);\n    if (xOff < threshold && yOff < threshold) {\n      return true;\n    }\n    return false;\n  };\n\n  // Thanks Mikko Mononen! https://github.com/memononen/stylii\n  const snapDeltaToAngle = function (delta, snapAngle) {\n    let angle = Math.atan2(delta.y, delta.x);\n    angle = Math.round(angle / snapAngle) * snapAngle;\n    const dirx = Math.cos(angle);\n    const diry = Math.sin(angle);\n    const d = dirx * delta.x + diry * delta.y;\n    return new paper.Point(dirx * d, diry * d);\n  };\n\n  // https://github.com/LLK/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/layer.js\n  const CROSSHAIR_FULL_OPACITY = 0.75;\n\n  const _getLayer = function (layerString) {\n    for (const layer of paper.project.layers) {\n      if (layer.data && layer.data[layerString]) {\n        return layer;\n      }\n    }\n  };\n\n  const getDragCrosshairLayer = function () {\n    return _getLayer(\"isDragCrosshairLayer\");\n  };\n  const getGuideLayer = function () {\n    return _getLayer(\"isGuideLayer\");\n  };\n\n  // https://github.com/LLK/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/view.js\n\n  // Vectors are imported and exported at SVG_ART_BOARD size.\n  // Once they are imported however, both SVGs and bitmaps are on\n  // canvases of ART_BOARD size.\n  // (This is for backwards compatibility, to handle both assets\n  // designed for 480 x 360, and bitmap resolution 2 bitmaps)\n  const SVG_ART_BOARD_WIDTH = 480;\n  const SVG_ART_BOARD_HEIGHT = 360;\n  const ART_BOARD_WIDTH = SVG_ART_BOARD_WIDTH * 2;\n  const ART_BOARD_HEIGHT = SVG_ART_BOARD_HEIGHT * 2;\n  const CENTER = new paper.Point(ART_BOARD_WIDTH / 2, ART_BOARD_HEIGHT / 2);\n  const ART_BOARD_BOUNDS = new paper.Rectangle(0, 0, ART_BOARD_WIDTH, ART_BOARD_HEIGHT);\n  const MAX_WORKSPACE_BOUNDS = new paper.Rectangle(\n    -ART_BOARD_WIDTH / 4,\n    -ART_BOARD_HEIGHT / 4,\n    ART_BOARD_WIDTH * 1.5,\n    ART_BOARD_HEIGHT * 1.5\n  );\n\n  /**\n   * Mouse actions are clamped to action bounds\n   * @param {boolean} isBitmap True if the editor is in bitmap mode, false if it is in vector mode\n   * @returns {paper.Rectangle} the bounds within which mouse events should work in the paint editor\n   */\n  const getActionBounds = (isBitmap) => {\n    if (isBitmap) {\n      return ART_BOARD_BOUNDS;\n    }\n    return paper.view.bounds.unite(ART_BOARD_BOUNDS).intersect(MAX_WORKSPACE_BOUNDS);\n  };\n\n  const setDefaultGuideStyle = function (item) {\n    item.strokeWidth = 1 / paper.view.zoom;\n    item.opacity = 1;\n    item.blendMode = \"normal\";\n    item.guide = true;\n  };\n\n  const GUIDE_BLUE = \"#009dec\";\n\n  const hoverBounds = function (item, expandBy) {\n    let bounds = item.internalBounds;\n    if (expandBy) {\n      bounds = bounds.expand(expandBy);\n    }\n    const rect = new paper.Path.Rectangle(bounds);\n    rect.matrix = item.matrix;\n    setDefaultGuideStyle(rect);\n    rect.parent = getGuideLayer();\n    rect.strokeColor = GUIDE_BLUE;\n    rect.fillColor = null;\n    rect.data.isHelperItem = true;\n    rect.data.origItem = item;\n    rect.bringToFront();\n\n    return rect;\n  };\n\n  return {\n    math: {\n      checkPointsClose,\n      snapDeltaToAngle,\n    },\n    layer: { CROSSHAIR_FULL_OPACITY, getDragCrosshairLayer, getLayer: _getLayer },\n    view: { CENTER, ART_BOARD_BOUNDS, MAX_WORKSPACE_BOUNDS, getActionBounds },\n    guide: { hoverBounds },\n  };\n}\n\nconst keyMirror = (obj) => Object.fromEntries(Object.entries(obj).map(([k]) => [k, k]));\n\n// https://github.com/LLK/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/lib/modes.js\n\nconst vectorModesObj = {\n  BRUSH: null,\n  ERASER: null,\n  LINE: null,\n  FILL: null,\n  SELECT: null,\n  RESHAPE: null,\n  OVAL: null,\n  RECT: null,\n  ROUNDED_RECT: null,\n  TEXT: null,\n};\nconst bitmapModesObj = {\n  BIT_BRUSH: null,\n  BIT_LINE: null,\n  BIT_OVAL: null,\n  BIT_RECT: null,\n  BIT_TEXT: null,\n  BIT_FILL: null,\n  BIT_ERASER: null,\n  BIT_SELECT: null,\n};\nconst VectorModes = keyMirror(vectorModesObj);\nconst BitmapModes = keyMirror(bitmapModesObj);\nconst Modes = keyMirror({ ...vectorModesObj, ...bitmapModesObj });\n\nconst GradientToolsModes = keyMirror({\n  FILL: null,\n  SELECT: null,\n  RESHAPE: null,\n  OVAL: null,\n  RECT: null,\n  LINE: null,\n\n  BIT_OVAL: null,\n  BIT_RECT: null,\n  BIT_SELECT: null,\n  BIT_FILL: null,\n});\n\nexport { Modes, VectorModes, BitmapModes, GradientToolsModes };\n","export let snapOn = true;\n\n//const ls = localStorage;\n\nexport const snapTo = {\n  pageEdges: true,\n  pageCenter: true,\n  pageAxes: true,\n  pageCorners: false,\n  objectEdges: true,\n  objectCenters: true,\n  objectMidlines: true,\n  objectCorners: false,\n};\nexport const snapFrom = {\n  boxCenter: true,\n  boxCorners: false,\n  boxEdgeMids: false,\n};\n\nexport let threshold = 10;\n\nexport let guideColor;\n\n/**\n *\n * @param {import(\"../../addon-api/content-script/typedef\").UserscriptAddon} addon\n */\nexport function loadSettings({ settings }) {\n  for (const point in snapTo) {\n    if (Object.prototype.hasOwnProperty.call(snapTo, point)) setSnapTo(point, settings.get(point));\n  }\n  for (const point in snapFrom) {\n    if (Object.prototype.hasOwnProperty.call(snapFrom, point)) setSnapFrom(point, settings.get(point));\n  }\n  setThreshold(settings.get(\"threshold\"));\n  toggle(settings.get(\"enable-default\"));\n}\n\n// Will update for addon storage api, but not yet.\n/*if (ls.getItem(\"sa-paint-snap-snapTo\")) {\n  const stored = JSON.parse(ls.getItem(\"sa-paint-snap-snapTo\"));\n  Object.assign(snapTo, stored);\n}\n\nif (ls.getItem(\"sa-paint-snap-snapFrom\")) {\n  const stored = JSON.parse(ls.getItem(\"sa-paint-snap-snapFrom\"));\n  Object.assign(snapFrom, stored);\n}\n\nif (ls.getItem(\"sa-paint-snap-threshold\")) {\n  const stored = JSON.parse(ls.getItem(\"sa-paint-snap-threshold\"));\n  threshold = stored;\n}*/\n\nexport function setSnapTo(point, to) {\n  snapTo[point] = !!to;\n  //ls.setItem(\"sa-paint-snap-snapTo\", JSON.stringify(snapTo));\n}\nexport function setSnapFrom(point, to) {\n  snapFrom[point] = !!to;\n  //ls.setItem(\"sa-paint-snap-snapFrom\", JSON.stringify(snapFrom));\n}\n\nexport function setThreshold(thresh) {\n  threshold = thresh;\n  //ls.setItem(\"sa-paint-snap-threshold\", JSON.stringify(threshold));\n}\n\nexport function enable() {\n  snapOn = true;\n}\n\nexport function disable() {\n  snapOn = false;\n}\n\nexport function toggle(enabled) {\n  if (enabled) enable();\n  else disable();\n}\n\nexport function setGuideColor(hex) {\n  guideColor = hex;\n}\n","import { setSnapFrom, setSnapTo, snapOn, snapFrom, snapTo, toggle, threshold, setThreshold } from \"./state.js\";\n\n/** @type {import(\"../../addon-api/content-script/typedef\").UserscriptUtilities} */\nexport function initUI({ addon, msg }) {\n  const createGroup = () => {\n    const el = document.createElement(\"div\");\n    el.className = \"sa-paint-snap-group\";\n    return el;\n  };\n  const createSeparator = () => {\n    const el = document.createElement(\"div\");\n    el.className = \"sa-paint-snap-settings-separator\";\n    return el;\n  };\n\n  const createButton = ({ useButtonTag } = {}) => {\n    const el = document.createElement(useButtonTag ? \"button\" : \"span\");\n    el.className = \"sa-paint-snap-button\";\n    el.setAttribute(\"role\", \"button\");\n    return el;\n  };\n\n  const createButtonImage = (name) => {\n    const el = document.createElement(\"img\");\n    el.className = \"sa-paint-snap-image\";\n    el.draggable = false;\n    el.src = addon.self.getResource(\"/icons/\" + name + \".svg\") /* rewritten by pull.js */;\n    return el;\n  };\n\n  const controlsGroup = createGroup();\n  addon.tab.displayNoneWhileDisabled(controlsGroup, {\n    display: \"flex\",\n  });\n\n  const settingPageWrapper = document.createElement(\"div\");\n  settingPageWrapper.className = \"sa-paint-snap-settings-wrapper\";\n  controlsGroup.appendChild(settingPageWrapper);\n\n  const settingsPage = document.createElement(\"div\");\n  settingsPage.className = \"sa-paint-snap-settings\";\n  settingPageWrapper.appendChild(settingsPage);\n\n  //todo msg\n  const SVG_NS = \"http://www.w3.org/2000/svg\";\n  const settingsTip = document.createElementNS(SVG_NS, \"svg\");\n  settingsTip.setAttribute(\"class\", \"sa-paint-snap-settings-tip\");\n  settingsTip.setAttribute(\"width\", \"14\");\n  settingsTip.setAttribute(\"height\", \"7\");\n  const settingsTipShape = document.createElementNS(SVG_NS, \"polygon\");\n  settingsTipShape.setAttribute(\"class\", \"sa-paint-snap-settings-polygon\");\n  settingsTipShape.setAttribute(\"points\", \"0,0 7,7, 14,0\");\n  settingsTip.appendChild(settingsTipShape);\n  settingsPage.appendChild(settingsTip);\n\n  const toggleButton = createButton();\n  toggleButton.addEventListener(\"click\", () => {\n    if (!snapOn) {\n      if (!Object.values(snapTo).some((e) => e)) {\n        setSnapTo(\"pageCenter\", true);\n      }\n      if (!Object.values(snapFrom).some((e) => e)) {\n        setSnapFrom(\"boxCenter\", true);\n      }\n    }\n    toggle(!snapOn);\n    toggleButton.dataset.enabled = snapOn;\n  });\n  toggleButton.title = msg(\"toggle\");\n  toggleButton.appendChild(createButtonImage(\"snap\"));\n  toggleButton.dataset.enabled = snapOn;\n  controlsGroup.appendChild(toggleButton);\n\n  const settingButton = createButton();\n  settingButton.addEventListener(\"click\", () => setSettingsOpen(!areSettingsOpen()));\n  settingButton.title = msg(\"settings\");\n  settingButton.appendChild(createButtonImage(\"settings\"));\n  controlsGroup.appendChild(settingButton);\n\n  const settingsOpenUpdaters = [];\n\n  const setSettingsOpen = (open) => {\n    settingButton.dataset.enabled = open;\n    settingsPage.dataset.visible = open;\n    if (open)\n      settingsOpenUpdaters.forEach((f) => {\n        try {\n          f?.();\n        } catch {}\n      });\n    else if (Object.values(snapFrom).every((e) => !e) || Object.values(snapTo).every((e) => !e)) {\n      toggle(false);\n      toggleButton.dataset.enabled = false;\n    }\n  };\n  const areSettingsOpen = () => settingsPage.dataset.visible === \"true\";\n\n  const createToggle = (button1Text, button2Text, defaultValue, onChange = () => {}) => {\n    const values = [button1Text, button2Text];\n    const group = createGroup();\n    const button1 = createButton({ useButtonTag: true });\n    const button2 = createButton({ useButtonTag: true });\n\n    const icon1 = createButtonImage(button1Text);\n    const icon2 = createButtonImage(button2Text);\n\n    icon1.dataset.shrink = icon2.dataset.shrink = true;\n\n    button1.appendChild(icon1);\n    button2.appendChild(icon2);\n\n    button1.setAttribute(\"aria-label\", (button1.title = msg(button1Text)));\n    button2.setAttribute(\"aria-label\", (button2.title = msg(button2Text)));\n\n    const setSelectedButton = (button, e, suppress = false) => {\n      button1.dataset.enabled = !!button;\n      button2.dataset.enabled = !button;\n      if (!suppress) onChange(values[button]);\n    };\n\n    setSelectedButton(1 - values.indexOf(defaultValue), null, true);\n\n    button1.addEventListener(\"click\", setSelectedButton.bind(button1, 1));\n    button2.addEventListener(\"click\", setSelectedButton.bind(button2, 0));\n\n    group.append(button1, button2);\n\n    return group;\n  };\n  const createNumberInput = (defaultValue, onChange = () => {}, min = -Infinity, max = Infinity, step = 1) => {\n    const group = createGroup();\n    const filler = document.createElement(\"div\");\n    filler.style.width = \"20px\";\n\n    const valueButton = createButton();\n    valueButton.appendChild(filler);\n    const valueInput = document.createElement(\"input\");\n    valueInput.className = \"sa-paint-snap-settings-input\";\n    valueInput.type = \"number\";\n    valueInput.step = step;\n    valueInput.min = min;\n    valueInput.max = max;\n    valueInput.value = defaultValue;\n    valueInput.addEventListener(\"change\", () => {\n      if (valueInput.value > max) valueInput.value = max;\n      if (valueInput.value < min) valueInput.value = min;\n      onChange(valueInput.value);\n    });\n    valueInput.addEventListener(\"blur\", () => {\n      if (!valueInput.value) valueInput.value = \"0\";\n    });\n    valueButton.appendChild(valueInput);\n\n    const decrementButton = createButton();\n    decrementButton.appendChild(createButtonImage(\"decrement\"));\n    decrementButton.addEventListener(\"click\", () => {\n      if (valueInput.value > min) {\n        valueInput.value = Number(valueInput.value) - 1;\n        onChange(Number(valueInput.value) + 1);\n      }\n    });\n\n    const incrementButton = createButton();\n    incrementButton.appendChild(createButtonImage(\"increment\"));\n    incrementButton.addEventListener(\"click\", () => {\n      if (valueInput.value < max) {\n        valueInput.value = Number(valueInput.value) + 1;\n        onChange(Number(valueInput.value) + 1);\n      }\n    });\n\n    group.append(decrementButton, valueButton, incrementButton);\n\n    return group;\n  };\n\n  const createSettingWithLabel = (settingId, settingElem) => {\n    const container = document.createElement(\"label\");\n    container.className = \"sa-paint-snap-settings-line\";\n\n    const labelElem = document.createElement(\"div\");\n    labelElem.className = \"sa-paint-snap-settings-label\";\n    labelElem.textContent = msg(settingId);\n    container.append(labelElem, settingElem);\n\n    settingsOpenUpdaters.push(() => {\n      const onBtn = settingElem.querySelector(`[aria-label=\"${msg(\"on\")}\"]`);\n      const offBtn = settingElem.querySelector(`[aria-label=\"${msg(\"off\")}\"]`);\n      if (settingId in snapTo) {\n        onBtn.dataset.enabled = !!snapTo[settingId];\n        offBtn.dataset.enabled = !snapTo[settingId];\n      }\n      if (settingId in snapFrom) {\n        onBtn.dataset.enabled = !!snapFrom[settingId];\n        offBtn.dataset.enabled = !snapFrom[settingId];\n      }\n    });\n\n    return container;\n  };\n\n  const createSection = (title, ...settingElems) => {\n    const sectionContainer = document.createElement(\"div\");\n    sectionContainer.className = \"sa-paint-snap-settings-section\";\n\n    const titleElem = document.createElement(\"span\");\n    titleElem.appendChild(document.createTextNode(title));\n    titleElem.className = \"sa-paint-snap-settings-section-title\";\n    sectionContainer.appendChild(titleElem);\n\n    sectionContainer.append(...settingElems);\n\n    return sectionContainer;\n  };\n\n  const threshSetting = createSettingWithLabel(\n    \"threshold\",\n    createNumberInput(\n      threshold,\n      (value) => {\n        setThreshold(value);\n      },\n      4,\n      50,\n      1\n    )\n  );\n\n  const toOnOff = (bool) => (bool ? \"on\" : \"off\");\n  const toBool = (onOff) => !![\"on\", \"off\"].indexOf(onOff);\n  const toggleParams = (defaultValue, onChange = () => {}) => [\n    \"off\",\n    \"on\",\n    toOnOff(defaultValue),\n    (value) => onChange(toBool(value)),\n  ];\n  const createSnapToSetting = (forPoint) =>\n    createSettingWithLabel(\n      forPoint,\n      createToggle(\n        ...toggleParams(snapTo[forPoint], (enabled) => {\n          toggle(true);\n          toggleButton.dataset.enabled = true;\n          setSnapTo(forPoint, enabled);\n        })\n      )\n    );\n  const snapToSection = createSection(\n    msg(\"snapTo\"),\n    createSnapToSetting(\"pageCenter\"),\n    createSnapToSetting(\"pageAxes\"),\n    createSnapToSetting(\"pageEdges\"),\n    createSnapToSetting(\"pageCorners\"),\n    createSnapToSetting(\"objectCenters\"),\n    createSnapToSetting(\"objectMidlines\"),\n    createSnapToSetting(\"objectEdges\"),\n    createSnapToSetting(\"objectCorners\")\n  );\n\n  const createSnapFromSetting = (forPoint) =>\n    createSettingWithLabel(\n      forPoint,\n      createToggle(\n        ...toggleParams(snapFrom[forPoint], (enabled) => {\n          setSnapFrom(forPoint, enabled);\n        })\n      )\n    );\n\n  const snapFromSection = createSection(\n    msg(\"snapFrom\"),\n    createSnapFromSetting(\"boxCenter\"),\n    createSnapFromSetting(\"boxCorners\"),\n    createSnapFromSetting(\"boxEdgeMids\")\n  );\n\n  settingsPage.append(threshSetting, createSeparator(), snapToSection, createSeparator(), snapFromSection);\n\n  const controlsLoop = async () => {\n    let hasRunOnce = false;\n    while (true) {\n      const canvasControls = await addon.tab.waitForElement(\"[class^='paint-editor_canvas-controls']\", {\n        markAsSeen: true,\n        reduxEvents: [\n          \"scratch-gui/navigation/ACTIVATE_TAB\",\n          \"scratch-gui/mode/SET_PLAYER\",\n          \"fontsLoaded/SET_FONTS_LOADED\",\n          \"scratch-gui/locales/SELECT_LOCALE\",\n          \"scratch-gui/targets/UPDATE_TARGET_LIST\",\n        ],\n        reduxCondition: (state) =>\n          state.scratchGui.editorTab.activeTabIndex === 1 && !state.scratchGui.mode.isPlayerOnly,\n      });\n      const zoomControlsContainer = canvasControls.querySelector(\"[class^='paint-editor_zoom-controls']\");\n      addon.tab.appendToSharedSpace({\n        space: \"paintEditorZoomControls\",\n        element: controlsGroup,\n        order: 2,\n      });\n\n      if (!hasRunOnce) {\n        hasRunOnce = true;\n        const groupClass = zoomControlsContainer.firstChild.className;\n        const buttonClass = zoomControlsContainer.firstChild.firstChild.className;\n        const imageClass = zoomControlsContainer.firstChild.firstChild.firstChild.className;\n        for (const el of document.querySelectorAll(\".sa-paint-snap-group\")) {\n          el.className += \" \" + groupClass;\n        }\n        for (const el of document.querySelectorAll(\".sa-paint-snap-button\")) {\n          el.className += \" \" + buttonClass;\n        }\n        for (const el of document.querySelectorAll(\".sa-paint-snap-image\")) {\n          el.className += \" \" + imageClass;\n        }\n      }\n    }\n  };\n  controlsLoop();\n}\n","import createScalePoints from \"./genScalePoints.js\";\nimport createSnapPoints from \"./genSnapPoints.js\";\nimport { loadModules, Modes, BitmapModes } from \"./helpers.js\";\n\nimport { snapOn, threshold, guideColor } from \"./state.js\";\n\nconst getScaleTool = (tool) => {\n  return tool.boundingBoxTool._modeMap.SCALE;\n};\n\nexport const updateScaleTool = (paper, tool) => {\n  const lib = loadModules(paper);\n  const {\n    view: { getActionBounds },\n    layer: { getLayer },\n  } = lib;\n\n  const scaleTool = getScaleTool(tool);\n\n  // https://github.com/LLK/scratch-paint/blob/develop/src/helper/selection-tools/scale-tool.js\n  const MIN_SCALE_FACTOR = 0.0001;\n\n  const selectionSizeGuide = {\n    endLeft: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      selected: false,\n    }),\n    endRight: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      selected: false,\n    }),\n    line: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      selected: false,\n    }),\n    group: new paper.Group({ children: [], visible: false }),\n  };\n  const matchingSizeGuide = {\n    endLeft: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      selected: false,\n    }),\n    endRight: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      selected: false,\n    }),\n    line: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      selected: false,\n    }),\n    group: new paper.Group({ children: [], visible: false }),\n  };\n\n  selectionSizeGuide.endLeft.remove();\n  matchingSizeGuide.endLeft.remove();\n  selectionSizeGuide.endRight.remove();\n  matchingSizeGuide.endRight.remove();\n  selectionSizeGuide.line.remove();\n  matchingSizeGuide.line.remove();\n  selectionSizeGuide.group.remove();\n  matchingSizeGuide.group.remove();\n\n  selectionSizeGuide.group.addChildren([\n    selectionSizeGuide.endLeft,\n    selectionSizeGuide.line,\n    selectionSizeGuide.endRight,\n  ]);\n  matchingSizeGuide.group.addChildren([matchingSizeGuide.endLeft, matchingSizeGuide.line, matchingSizeGuide.endRight]);\n\n  let axisLineX = new paper.Path.Line({\n    from: [0, 0],\n    to: [0, 0],\n    strokeColor: new paper.Color(guideColor),\n    strokeWidth: 1 / paper.view.zoom,\n    visible: false,\n    data: {\n      isHelperItem: true,\n      noSelect: true,\n      noHover: true,\n      saPaintSnapGuide: true,\n      axis: \"x\",\n    },\n    selected: false,\n  });\n  let axisLineY = new paper.Path.Line({\n    from: [0, 0],\n    to: [0, 0],\n    strokeColor: new paper.Color(guideColor),\n    strokeWidth: 1 / paper.view.zoom,\n    visible: false,\n    data: {\n      isHelperItem: true,\n      noSelect: true,\n      noHover: true,\n      saPaintSnapGuide: true,\n      axis: \"y\",\n    },\n    selected: false,\n  });\n  axisLineX.remove();\n  axisLineY.remove();\n\n  const fixGuideSizes = () => {\n    axisLineX.strokeWidth = 1 / paper.view.zoom;\n    axisLineY.strokeWidth = 1 / paper.view.zoom;\n    axisLineX.strokeColor = new paper.Color(guideColor);\n    axisLineY.strokeColor = new paper.Color(guideColor);\n\n    selectionSizeGuide.endLeft.strokeWidth = 1 / paper.view.zoom;\n    matchingSizeGuide.endLeft.strokeWidth = 1 / paper.view.zoom;\n    selectionSizeGuide.endRight.strokeWidth = 1 / paper.view.zoom;\n    matchingSizeGuide.endRight.strokeWidth = 1 / paper.view.zoom;\n    selectionSizeGuide.line.strokeWidth = 1 / paper.view.zoom;\n    matchingSizeGuide.line.strokeWidth = 1 / paper.view.zoom;\n\n    selectionSizeGuide.endLeft.strokeColor = new paper.Color(guideColor);\n    matchingSizeGuide.endLeft.strokeColor = new paper.Color(guideColor);\n    selectionSizeGuide.endRight.strokeColor = new paper.Color(guideColor);\n    matchingSizeGuide.endRight.strokeColor = new paper.Color(guideColor);\n    selectionSizeGuide.line.strokeColor = new paper.Color(guideColor);\n    matchingSizeGuide.line.strokeColor = new paper.Color(guideColor);\n\n    axisLineX.bringToFront();\n    axisLineY.bringToFront();\n    getLayer(\"isGuideLayer\").addChildren([axisLineY, axisLineX, selectionSizeGuide.group, matchingSizeGuide.group]);\n  };\n\n  const priority = [\"width\", \"height\", \"itemSideVert\", \"itemSideHoriz\", \"xcoord\", \"ycoord\", \"generated\", undefined];\n\n  const removeGuides = () => {\n    selectionSizeGuide.group.remove();\n    selectionSizeGuide.group.visible = false;\n\n    matchingSizeGuide.group.remove();\n    matchingSizeGuide.group.visible = false;\n\n    axisLineX.remove();\n    axisLineX.visible = false;\n    axisLineY.remove();\n    axisLineY.visible = false;\n  };\n\n  scaleTool.constructor.prototype.onMouseDrag = function (event) {\n    if (!this.active) return;\n    const point = event.point;\n    const bounds = getActionBounds(this.isBitmap);\n    point.x = Math.max(bounds.left, Math.min(point.x, bounds.right));\n    point.y = Math.max(bounds.top, Math.min(point.y, bounds.bottom));\n\n    if (!this.lastPoint) this.lastPoint = event.lastPoint;\n\n    const delta = point.subtract(this.lastPoint);\n    this.lastPoint = point;\n\n    if (event.modifiers.alt) {\n      this.centered = true;\n      this.itemGroup.position = this.origCenter;\n      this.pivot = this.origCenter;\n    } else {\n      if (this.centered) {\n        // Reset position if we were just in alt\n        this.centered = false;\n        this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);\n        if (this.selectionAnchor) {\n          this.selectionAnchor.scale(this.lastSx, this.lastSy);\n        }\n        this.lastSx = 1;\n        this.lastSy = 1;\n      }\n      this.pivot = this.origPivot;\n    }\n\n    this.corner = this.corner.add(delta);\n    let size = this.corner.subtract(this.pivot);\n    if (event.modifiers.alt) {\n      size = size.multiply(2);\n    }\n    let sx = 1.0;\n    let sy = 1.0;\n    if (Math.abs(this.origSize.x) > 0.0000001) {\n      sx = size.x / this.origSize.x;\n    }\n    if (Math.abs(this.origSize.y) > 0.0000001) {\n      sy = size.y / this.origSize.y;\n    }\n\n    const sortByPrioOrDist = (a, b) => {\n      const prioDiff = priority.indexOf(a.type) - priority.indexOf(b.type);\n      if (prioDiff) return prioDiff;\n      return a.distance - b.distance;\n    };\n    const paintLayer = getLayer(\"isPaintingLayer\");\n\n    const doesSx = snapOn && ((this.isCorner && !event.modifiers.shift) || Math.abs(this.origSize.x) > 0.0000001);\n    const doesSy = snapOn && ((this.isCorner && !event.modifiers.shift) || Math.abs(this.origSize.y) > 0.0000001);\n\n    const scaledThreshold = threshold / paper.view.zoom;\n\n    const canSnap = (coord) => coord.distance < scaledThreshold;\n\n    const format = ([coordName, coord]) => ({\n      type: coord.type,\n      distance: (() => {\n        switch (coord.type) {\n          case \"width\": {\n            return Math.abs(Math.abs(size.x) - Math.abs(coord.clamp.max - coord.clamp.min));\n          }\n          case \"height\": {\n            return Math.abs(Math.abs(size.y) - Math.abs(coord.clamp.max - coord.clamp.min));\n          }\n          case \"xcoord\":\n          case \"itemSideVert\": {\n            return Math.abs(this.corner.x - coord.value);\n          }\n          case \"ycoord\":\n          case \"itemSideHoriz\": {\n            return Math.abs(this.corner.y - coord.value);\n          }\n          default:\n            break;\n        }\n      })(),\n      name: coordName,\n      coord: coord,\n    });\n\n    const snapXCoords = createScalePoints(paper, lib, paintLayer.children, doesSx, false);\n\n    const canSnapXCoords = Object.entries(snapXCoords).map(format).filter(canSnap).sort(sortByPrioOrDist);\n\n    const snapYCoords = createScalePoints(paper, lib, paintLayer.children, false, doesSy);\n\n    const canSnapYCoords = Object.entries(snapYCoords).map(format).filter(canSnap).sort(sortByPrioOrDist);\n\n    const closestSnapX = canSnapXCoords[0];\n    const closestSnapY = canSnapYCoords[0];\n\n    const signx = sx > 0 ? 1 : -1;\n    const signy = sy > 0 ? 1 : -1;\n    // TODO: show correct guides\n    if (closestSnapX) {\n      switch (closestSnapX.type) {\n        case \"width\": {\n          const newSize = new paper.Point(\n            Math.abs(closestSnapX.coord.clamp.max - closestSnapX.coord.clamp.min),\n            this.corner.y\n          );\n          sx = newSize.x / this.origSize.x;\n          break;\n        }\n        case \"xcoord\":\n        case \"itemSideVert\": {\n          const newSize = new paper.Point(closestSnapX.coord.value, this.corner.y).subtract(this.pivot);\n          sx = newSize.x / this.origSize.x;\n          if (event.modifiers.alt) sx *= 2;\n          break;\n        }\n        default:\n          break;\n      }\n    }\n    if (closestSnapY) {\n      switch (closestSnapY.type) {\n        case \"height\": {\n          const newSize = new paper.Point(\n            this.corner.x,\n            Math.abs(closestSnapY.coord.clamp.max - closestSnapY.coord.clamp.min)\n          );\n          sy = newSize.y / this.origSize.y;\n          break;\n        }\n        case \"ycoord\":\n        case \"itemSideHoriz\": {\n          const newSize = new paper.Point(this.corner.x, closestSnapY.coord.value).subtract(this.pivot);\n          sy = newSize.y / this.origSize.y;\n          if (event.modifiers.alt) sy *= 2;\n          break;\n        }\n        default:\n          break;\n      }\n    }\n\n    const oldSX = sx;\n    const oldSY = sy;\n\n    if (this.isCorner && !event.modifiers.shift) {\n      sx = sy = Math.max(Math.abs(sx), Math.abs(sy));\n      sx *= signx;\n      sy *= signy;\n    }\n\n    sx = signx * Math.max(Math.abs(sx), MIN_SCALE_FACTOR);\n    sy = signy * Math.max(Math.abs(sy), MIN_SCALE_FACTOR);\n\n    this.itemGroup.scale(sx / this.lastSx, sy / this.lastSy, this.pivot);\n    if (this.selectionAnchor) {\n      this.selectionAnchor.scale(this.lastSx / sx, this.lastSy / sy);\n    }\n\n    removeGuides();\n\n    if ((Math.abs(oldSX) === Math.abs(sx) && closestSnapX) || (Math.abs(oldSY) === Math.abs(sy) && closestSnapY))\n      fixGuideSizes();\n\n    if (Math.abs(oldSX) === Math.abs(sx) && closestSnapX) {\n      switch (closestSnapX.type) {\n        case \"width\": {\n          const matchy = closestSnapX.coord.value;\n          const selectiony = this.itemGroup.bounds.bottom;\n\n          matchingSizeGuide.endLeft.firstSegment.point = new paper.Point(closestSnapX.coord.clamp.min, matchy);\n          matchingSizeGuide.endLeft.lastSegment.point = new paper.Point(\n            closestSnapX.coord.clamp.min,\n            matchy + 5 / paper.view.zoom\n          );\n          matchingSizeGuide.endRight.firstSegment.point = new paper.Point(closestSnapX.coord.clamp.max, matchy);\n          matchingSizeGuide.endRight.lastSegment.point = new paper.Point(\n            closestSnapX.coord.clamp.max,\n            matchy + 5 / paper.view.zoom\n          );\n          matchingSizeGuide.line.firstSegment.point = new paper.Point(\n            closestSnapX.coord.clamp.min,\n            matchy + 3 / paper.view.zoom\n          );\n          matchingSizeGuide.line.lastSegment.point = new paper.Point(\n            closestSnapX.coord.clamp.max,\n            matchy + 3 / paper.view.zoom\n          );\n          matchingSizeGuide.group.visible = true;\n          matchingSizeGuide.group.bringToFront();\n\n          selectionSizeGuide.endLeft.firstSegment.point = new paper.Point(\n            this.itemGroup.bounds.left,\n            selectiony + 2 / paper.view.zoom\n          );\n          selectionSizeGuide.endLeft.lastSegment.point = new paper.Point(\n            this.itemGroup.bounds.left,\n            selectiony + 7 / paper.view.zoom\n          );\n          selectionSizeGuide.endRight.firstSegment.point = new paper.Point(\n            this.itemGroup.bounds.right,\n            selectiony + 2 / paper.view.zoom\n          );\n          selectionSizeGuide.endRight.lastSegment.point = new paper.Point(\n            this.itemGroup.bounds.right,\n            selectiony + 7 / paper.view.zoom\n          );\n          selectionSizeGuide.line.firstSegment.point = new paper.Point(\n            this.itemGroup.bounds.left,\n            selectiony + 4.5 / paper.view.zoom\n          );\n          selectionSizeGuide.line.lastSegment.point = new paper.Point(\n            this.itemGroup.bounds.right,\n            selectiony + 4.5 / paper.view.zoom\n          );\n          selectionSizeGuide.group.visible = true;\n          selectionSizeGuide.group.bringToFront();\n          break;\n        }\n        case \"xcoord\":\n        case \"itemSideVert\": {\n          axisLineX.firstSegment.point = new paper.Point(closestSnapX.coord.value, bounds.top);\n          axisLineX.lastSegment.point = new paper.Point(closestSnapX.coord.value, bounds.bottom);\n          axisLineX.visible = true;\n          axisLineX.bringToFront();\n          break;\n        }\n        default:\n          break;\n      }\n    }\n    if (Math.abs(oldSY) === Math.abs(sy) && closestSnapY) {\n      switch (closestSnapY.type) {\n        case \"height\": {\n          const matchx = closestSnapY.coord.value;\n          const selectionx = this.itemGroup.bounds.left;\n\n          matchingSizeGuide.endLeft.firstSegment.point = new paper.Point(matchx, closestSnapY.coord.clamp.min);\n          matchingSizeGuide.endLeft.lastSegment.point = new paper.Point(\n            matchx - 5 / paper.view.zoom,\n            closestSnapY.coord.clamp.min\n          );\n          matchingSizeGuide.endRight.firstSegment.point = new paper.Point(matchx, closestSnapY.coord.clamp.max);\n          matchingSizeGuide.endRight.lastSegment.point = new paper.Point(\n            matchx - 5 / paper.view.zoom,\n            closestSnapY.coord.clamp.max\n          );\n          matchingSizeGuide.line.firstSegment.point = new paper.Point(\n            matchx - 3 / paper.view.zoom,\n            closestSnapY.coord.clamp.min\n          );\n          matchingSizeGuide.line.lastSegment.point = new paper.Point(\n            matchx - 3 / paper.view.zoom,\n            closestSnapY.coord.clamp.max\n          );\n          matchingSizeGuide.group.visible = true;\n          matchingSizeGuide.group.bringToFront();\n\n          selectionSizeGuide.endLeft.firstSegment.point = new paper.Point(\n            selectionx - 2 / paper.view.zoom,\n            this.itemGroup.bounds.top\n          );\n          selectionSizeGuide.endLeft.lastSegment.point = new paper.Point(\n            selectionx - 7 / paper.view.zoom,\n            this.itemGroup.bounds.top\n          );\n          selectionSizeGuide.endRight.firstSegment.point = new paper.Point(\n            selectionx - 2 / paper.view.zoom,\n            this.itemGroup.bounds.bottom\n          );\n          selectionSizeGuide.endRight.lastSegment.point = new paper.Point(\n            selectionx - 7 / paper.view.zoom,\n            this.itemGroup.bounds.bottom\n          );\n          selectionSizeGuide.line.firstSegment.point = new paper.Point(\n            selectionx - 4.5 / paper.view.zoom,\n            this.itemGroup.bounds.top\n          );\n          selectionSizeGuide.line.lastSegment.point = new paper.Point(\n            selectionx - 4.5 / paper.view.zoom,\n            this.itemGroup.bounds.bottom\n          );\n          selectionSizeGuide.group.visible = true;\n          selectionSizeGuide.group.bringToFront();\n          break;\n        }\n        case \"ycoord\":\n        case \"itemSideHoriz\": {\n          axisLineY.firstSegment.point = new paper.Point(bounds.left, closestSnapY.coord.value);\n          axisLineY.lastSegment.point = new paper.Point(bounds.right, closestSnapY.coord.value);\n          axisLineY.visible = true;\n          axisLineY.bringToFront();\n          break;\n        }\n        default:\n          break;\n      }\n    }\n\n    this.lastSx = sx;\n    this.lastSy = sy;\n  };\n\n  const oldMouseUp = scaleTool.constructor.prototype.onMouseUp;\n  scaleTool.constructor.prototype.onMouseUp = function () {\n    removeGuides();\n    oldMouseUp.call(this);\n  };\n};\n","import createSnapPoints from \"./genSnapPoints.js\";\nimport { loadModules, Modes, BitmapModes } from \"./helpers.js\";\n\nimport { snapOn, threshold, guideColor } from \"./state.js\";\n\nconst getMoveTool = (tool) => {\n  return tool.boundingBoxTool._modeMap.MOVE;\n};\n\nexport const updateSelectTool = (paper, tool) => {\n  const lib = loadModules(paper);\n  const {\n    math: { checkPointsClose, snapDeltaToAngle },\n    view: { getActionBounds, CENTER },\n    layer: { getDragCrosshairLayer, CROSSHAIR_FULL_OPACITY, getLayer },\n    guide: { hoverBounds },\n  } = lib;\n\n  const moveTool = getMoveTool(tool);\n\n  // https://github.com/LLK/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/selection-tools/move-tool.js\n\n  const FADE_DISTANCE = 10;\n\n  let guideLine = new paper.Path.Line({\n    from: [0, 0],\n    to: [0, 0],\n    strokeColor: new paper.Color(guideColor),\n    strokeWidth: 1 / paper.view.zoom,\n    visible: false,\n    data: {\n      isHelperItem: true,\n      noSelect: true,\n      noHover: true,\n      saPaintSnapGuide: true,\n    },\n    selected: false,\n  });\n\n  const guidePointParts = {\n    shadow: null,\n    circle: null,\n  };\n  const guidePoint = new paper.Group({ children: [], visible: false });\n\n  // Paper adds them by default, and we don't want them in the canvas yet.\n  guideLine.remove();\n  guidePoint.remove();\n\n  let itemIndicator;\n\n  const fixGuideSizes = () => {\n    guidePointParts.shadow = new paper.Path.Circle({\n      center: new paper.Point(0, 0),\n      radius: 5.5 / paper.view.zoom,\n      fillColor: \"black\",\n      opacity: 0.12,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      visible: true,\n      guide: true,\n    });\n    guidePointParts.circle = new paper.Path.Circle({\n      center: new paper.Point(0, 0),\n      radius: 4 / paper.view.zoom,\n      fillColor: new paper.Color(guideColor),\n      data: {\n        isScaleHandle: false,\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true,\n      },\n      visible: true,\n      guide: true,\n    });\n    guidePoint.removeChildren();\n    guidePoint.addChildren([guidePointParts.shadow, guidePointParts.circle]);\n    guideLine.strokeWidth = 1 / paper.view.zoom;\n    guideLine.strokeColor = new paper.Color(guideColor);\n    guideLine.bringToFront();\n    guidePoint.bringToFront();\n    getLayer(\"isGuideLayer\").addChildren([guideLine, guidePoint]);\n  };\n\n  let removeGuides;\n\n  function onMouseDrag(event) {\n    const point = event.point;\n    const actionBounds = getActionBounds(this.mode in BitmapModes);\n\n    point.x = Math.max(actionBounds.left, Math.min(point.x, actionBounds.right));\n    point.y = Math.max(actionBounds.top, Math.min(point.y, actionBounds.bottom));\n\n    const dragVector = point.subtract(event.downPoint);\n    const scaledThreshold = threshold / paper.view.zoom;\n\n    let snapVector;\n\n    if (this.selectedItems.length === 0) {\n      return;\n    }\n    const selectionBounds = this.selectionCenter._owner;\n    const newCenter = this.selectionCenter.add(dragVector);\n    const getDist = (p1, p2) => {\n      return p1.getDistance(p2);\n    };\n\n    const selectionAnchor =\n      getLayer(\"isGuideLayer\").children.find((c) => c.data.isSelectionBound)?.selectionAnchor ?? {};\n\n    const resetAnchorColor = () => {\n      selectionAnchor.strokeColor = new paper.Color(0.30196078431372547, 0.592156862745098, 1);\n      selectionAnchor.fillColor = null;\n    };\n\n    removeGuides = () => {\n      guideLine.remove();\n      guidePoint.remove();\n      guidePoint.visible = false;\n      guideLine.visible = false;\n      itemIndicator?.remove();\n      if (itemIndicator) itemIndicator.visible = false;\n      resetAnchorColor();\n    };\n\n    removeGuides();\n\n    if (!event.modifiers.shift && this.mode !== Modes.RESHAPE) {\n      const paintLayer = getLayer(\"isPaintingLayer\");\n\n      const snapPoints = createSnapPoints(paper, selectionBounds, lib, paintLayer.children);\n      const fromPoints = snapPoints.from;\n      const toPoints = snapPoints.to;\n\n      const configDefFn = (pointDef) => {\n        if (!pointDef.clamp)\n          pointDef.clamp = {\n            min: -Infinity,\n            max: Infinity,\n          };\n        if (pointDef.type === \"point\") return () => pointDef.value;\n        if (pointDef.type === \"xcoord\" || pointDef.type === \"itemSideVert\")\n          return (point) =>\n            new paper.Point(pointDef.value, Math.min(Math.max(point.y, pointDef.clamp.min), pointDef.clamp.max));\n        if (pointDef.type === \"ycoord\" || pointDef.type === \"itemSideHoriz\")\n          return (point) =>\n            new paper.Point(Math.min(Math.max(point.x, pointDef.clamp.min), pointDef.clamp.max), pointDef.value);\n        if (pointDef.type === \"generator\") return pointDef.value;\n      };\n      const generateSnapPointsFor = (point) =>\n        Object.fromEntries(\n          Object.entries(toPoints).map(([k, v]) => [k, { type: v.type, point: configDefFn(v)(point) }])\n        );\n\n      const generatedSnapPoints = Object.entries(fromPoints).map(([pointPos, point]) => ({\n        pointPos,\n        origPoint: point,\n        point: point.add(dragVector),\n        snapPoints: generateSnapPointsFor(point.add(dragVector)),\n      }));\n\n      const priority = [\"point\", \"itemSideVert\", \"itemSideHoriz\", \"xcoord\", \"ycoord\", \"generated\", undefined];\n\n      const sortByPrioOrDist = (a, b) => {\n        const prioDiff = priority.indexOf(a.snapPointType) - priority.indexOf(b.snapPointType);\n        if (prioDiff) return prioDiff;\n        return a.distance - b.distance;\n      };\n\n      const closestSnapForEachPoint = generatedSnapPoints\n        .map(({ point, origPoint, snapPoints }) => {\n          const snappablePoints = Object.entries(snapPoints)\n            .filter(([pos, snapPoint]) => checkPointsClose(point, snapPoint.point, scaledThreshold))\n            .map(([pos, snapPoint]) => ({\n              pos,\n              distance: getDist(snapPoint.point, point),\n              snapPointType: snapPoint.type,\n            }));\n\n          const closestSnapPoint = snappablePoints.sort(sortByPrioOrDist)[0] || {\n            pos: \"\",\n            distance: Infinity,\n          };\n\n          return {\n            point: origPoint,\n            snapPoint: snapPoints[closestSnapPoint.pos]?.point,\n            snapPointType: snapPoints[closestSnapPoint.pos]?.type,\n            distance: closestSnapPoint.distance,\n            pos: closestSnapPoint.pos,\n          };\n        })\n        .sort(sortByPrioOrDist);\n\n      const closestSnapPoint = closestSnapForEachPoint.sort(sortByPrioOrDist)[0];\n      removeGuides();\n      if (closestSnapPoint?.snapPoint) {\n        fixGuideSizes();\n        snapVector = closestSnapPoint.snapPoint.subtract(closestSnapPoint.point);\n        const itemID = closestSnapPoint.pos.match(/item_(\\d+)_/)?.[1];\n        if (itemID) {\n          const item = paper.project.getItem({\n            id: parseInt(itemID, 10),\n          });\n\n          if (item) {\n            itemIndicator = hoverBounds(item);\n          }\n        }\n        if (closestSnapPoint.point.equals(this.selectionCenter) && closestSnapPoint.snapPointType === \"point\") {\n          selectionAnchor.fillColor = selectionAnchor.strokeColor = new paper.Color(guideColor);\n        } else {\n          resetAnchorColor();\n          switch (closestSnapPoint.snapPointType) {\n            case \"point\": {\n              guidePoint.visible = true;\n              guidePoint.position = closestSnapPoint.snapPoint;\n              guidePoint.bringToFront();\n              break;\n            }\n            case \"xcoord\":\n            case \"itemSideVert\": {\n              guideLine.firstSegment.point = new paper.Point(closestSnapPoint.snapPoint.x, actionBounds.top);\n              guideLine.lastSegment.point = new paper.Point(closestSnapPoint.snapPoint.x, actionBounds.bottom);\n              guideLine.visible = true;\n              guideLine.bringToFront();\n              break;\n            }\n            case \"ycoord\":\n            case \"itemSideHoriz\": {\n              guideLine.firstSegment.point = new paper.Point(actionBounds.left, closestSnapPoint.snapPoint.y);\n              guideLine.lastSegment.point = new paper.Point(actionBounds.right, closestSnapPoint.snapPoint.y);\n              guideLine.visible = true;\n              guideLine.bringToFront();\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    let bounds;\n    for (const item of this.selectedItems) {\n      // add the position of the item before the drag started\n      // for later use in the snap calculation\n      if (!item.data.origPos) {\n        item.data.origPos = item.position;\n      }\n\n      if (snapVector) {\n        item.position = item.data.origPos.add(snapVector);\n      } else if (event.modifiers.shift) {\n        item.position = item.data.origPos.add(snapDeltaToAngle(dragVector, Math.PI / 4));\n      } else {\n        item.position = item.data.origPos.add(dragVector);\n      }\n\n      if (bounds) {\n        bounds = bounds.unite(item.bounds);\n      } else {\n        bounds = item.bounds;\n      }\n    }\n\n    if (this.firstDrag) {\n      // Show the center crosshair above the selected item while dragging.\n      getDragCrosshairLayer().visible = true;\n      this.firstDrag = false;\n    }\n\n    // The rotation center crosshair should be opaque over the entire selection bounding box, and fade out to\n    // totally transparent outside the selection bounding box.\n    let opacityMultiplier = 1;\n    if (\n      (CENTER.y < bounds.top && CENTER.x < bounds.left) ||\n      (CENTER.y > bounds.bottom && CENTER.x < bounds.left) ||\n      (CENTER.y < bounds.top && CENTER.x > bounds.right) ||\n      (CENTER.y > bounds.bottom && CENTER.x > bounds.right)\n    ) {\n      // rotation center is to one of the 4 corners of the selection bounding box\n      const distX = Math.max(CENTER.x - bounds.right, bounds.left - CENTER.x);\n      const distY = Math.max(CENTER.y - bounds.bottom, bounds.top - CENTER.y);\n      const dist = Math.sqrt(distX * distX + distY * distY);\n      opacityMultiplier = Math.max(0, 1 - dist / (FADE_DISTANCE / paper.view.zoom));\n    } else if (CENTER.y < bounds.top || CENTER.y > bounds.bottom) {\n      // rotation center is above or below the selection bounding box\n      opacityMultiplier = Math.max(\n        0,\n        1 - (Math.abs(CENTER.y - newCenter.y) - bounds.height / 2) / (FADE_DISTANCE / paper.view.zoom)\n      );\n    } else if (CENTER.x < bounds.left || CENTER.x > bounds.right) {\n      // rotation center is left or right of the selection bounding box\n      opacityMultiplier = Math.max(\n        0,\n        1 - (Math.abs(CENTER.x - newCenter.x) - bounds.width / 2) / (FADE_DISTANCE / paper.view.zoom)\n      );\n    } // else the rotation center is within selection bounds, always show drag crosshair at full opacity\n    getDragCrosshairLayer().opacity = CROSSHAIR_FULL_OPACITY * opacityMultiplier;\n  }\n\n  const oldMouseDrag = moveTool.constructor.prototype.onMouseDrag;\n  moveTool.constructor.prototype.onMouseDrag = onMouseDrag;\n\n  const oldMouseDown = moveTool.constructor.prototype.onMouseDown;\n  moveTool.constructor.prototype.onMouseDown = function (...a) {\n    if (snapOn) moveTool.constructor.prototype.onMouseDrag = onMouseDrag;\n    else moveTool.constructor.prototype.onMouseDrag = oldMouseDrag;\n\n    oldMouseDown.apply(this, a);\n  };\n\n  const oldMouseUp = moveTool.constructor.prototype.onMouseUp;\n  moveTool.constructor.prototype.onMouseUp = function (...a) {\n    removeGuides?.();\n    oldMouseUp.apply(this, a);\n  };\n};\n\nexport const isSelectTool = (tool) => {\n  return \"selectionBoxTool\" in tool && \"boundingBoxTool\" in tool;\n};\n","import { isSelectTool, updateSelectTool } from \"./updateSelectTool.js\";\nimport { enable, disable, loadSettings, setGuideColor, toggle } from \"./state.js\";\nimport { initUI } from \"./ui.js\";\nimport { updateScaleTool } from \"./updateScaleTool.js\";\n\n/** @type {(api: import(\"../../addon-api/content-script/typedef\").UserscriptUtilities) => Promise<void>} */\nexport default async function (api) {\n  const { addon } = api;\n  addon.self.addEventListener(\"disabled\", disable);\n  addon.self.addEventListener(\"reenabled\", enable);\n  loadSettings(addon);\n  const paper = await addon.tab.traps.getPaper();\n  const [tool] = paper.tools;\n\n  toggle(addon.settings.get(\"enable-default\"));\n  setGuideColor(addon.settings.get(\"guide-color\"));\n  addon.settings.addEventListener(\"change\", () => setGuideColor(addon.settings.get(\"guide-color\")));\n\n  if (isSelectTool(tool)) {\n    updateSelectTool(paper, tool);\n    updateScaleTool(paper, tool);\n  }\n  initUI(api);\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;;;;;;;;;;;;;;;;;;ACTA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AADA;AACA;AAGA;AAKA;AACA;AACA;AAFA;AADA;AASA;AACA;AACA;AAFA;AADA;AAaA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AATA;AAqBA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AATA;AAqBA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AADA;AAaA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AADA;AAsBA;AACA;AAFA;AAQA;AACA;AAFA;AAQA;AACA;AAFA;AAQA;AACA;AAFA;AAQA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAYA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAuBA;AACA;AAFA;AAQA;AACA;AAFA;AACA;AAWA;AACA;;;;;;;;;;;;;;;;;;;;;ACzLA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AADA;AACA;AAEA;AAGA;AADA;AAMA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AAJA;AACA;AAQA;AAGA;AACA;AACA;AAFA;AADA;AASA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AALA;AAaA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAQA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AA7CA;AAqDA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAbA;AA2BA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAYA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAYA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAYA;AACA;AACA;AACA;AACA;AAFA;AAHA;AAqBA;AACA;AAFA;AAiBA;AACA;AAFA;AAQA;AACA;AAFA;AAiBA;AACA;AAFA;AAQA;AACA;AAFA;AAQA;AACA;AAFA;AAQA;AACA;AAFA;AACA;AAUA;AACA;AACA;AAFA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;AClQA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAPA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAXA;;;;;;;;;;;;;AC5IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAMA;AACA;AAAA;AACA;AAAA;AACA;AAKA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAWA;AAKA;AACA;AACA;AAGA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAOA;AATA;AAYA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;AC9TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAcA;AAAA;AAAA;AAAA;AA3CA;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAcA;AAAA;AAAA;AAAA;AA3CA;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAhBA;AAkBA;AACA;AACA;AAvBA;AACA;AAyBA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAjBA;AAmBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAjBA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAIA;AAIA;AAIA;AACA;AAEA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA/DA;AAiEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAIA;AAIA;AAIA;AACA;AAEA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA/DA;AAiEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7fA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAOA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAZA;AAeA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAIA;AACA;AAGA;AAGA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAwBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;ACrUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;A","sourceRoot":""}