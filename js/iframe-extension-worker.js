(window["webpackJsonpGUI"] = window["webpackJsonpGUI"] || []).push([["iframe-extension-worker"],{

/***/ "./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const uid = __webpack_require__(/*! ../util/uid */ "./node_modules/scratch-vm/src/util/uid.js");

const frameSource = __webpack_require__(/*! ./tw-load-script-as-plain-text!./tw-iframe-extension-worker-entry */ "./node_modules/scratch-vm/src/extension-support/tw-load-script-as-plain-text.js!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js");

const none = "'none'";
const featurePolicy = {
  'accelerometer': none,
  'ambient-light-sensor': none,
  'battery': none,
  'camera': none,
  'display-capture': none,
  'document-domain': none,
  'encrypted-media': none,
  'fullscreen': none,
  'geolocation': none,
  'gyroscope': none,
  'magnetometer': none,
  'microphone': none,
  'midi': none,
  'payment': none,
  'picture-in-picture': none,
  'publickey-credentials-get': none,
  'speaker-selection': none,
  'usb': none,
  'vibrate': none,
  'vr': none,
  'screen-wake-lock': none,
  'web-share': none,
  'interest-cohort': none
};

const generateAllow = () => Object.entries(featurePolicy).map(([name, permission]) => "".concat(name, " ").concat(permission)).join('; ');

class IframeExtensionWorker {
  constructor() {
    this.id = uid();
    this.isRemote = true;
    this.ready = false;
    this.queuedMessages = [];
    this.iframe = document.createElement('iframe');
    this.iframe.className = 'tw-custom-extension-frame';
    this.iframe.dataset.id = this.id;
    this.iframe.style.display = 'none';
    this.iframe.setAttribute('aria-hidden', 'true');
    this.iframe.sandbox = 'allow-scripts';
    this.iframe.allow = generateAllow();
    document.body.appendChild(this.iframe);
    window.addEventListener('message', this._onWindowMessage.bind(this));
    const blob = new Blob([// eslint-disable-next-line max-len
    "<!DOCTYPE html><body><script>window.__WRAPPED_IFRAME_ID__=".concat(JSON.stringify(this.id), ";").concat(frameSource, "</script></body>")], {
      type: 'text/html; charset=utf-8'
    });
    this.iframe.src = URL.createObjectURL(blob);
  }

  _onWindowMessage(e) {
    if (!e.data || e.data.vmIframeId !== this.id) {
      return;
    }

    if (e.data.ready) {
      this.ready = true;

      for (const {
        data,
        transfer
      } of this.queuedMessages) {
        this.postMessage(data, transfer);
      }

      this.queuedMessages.length = 0;
    }

    if (e.data.message) {
      this.onmessage({
        data: e.data.message
      });
    }
  }

  onmessage() {// Should be overridden
  }

  postMessage(data, transfer) {
    if (this.ready) {
      if (transfer) {
        this.iframe.contentWindow.postMessage(data, '*', transfer);
      } else {
        this.iframe.contentWindow.postMessage(data, '*');
      }
    } else {
      this.queuedMessages.push({
        data,
        transfer
      });
    }
  }

}

module.exports = IframeExtensionWorker;

/***/ }),

/***/ "./node_modules/scratch-vm/src/extension-support/tw-load-script-as-plain-text.js!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/scratch-vm/src/extension-support/tw-load-script-as-plain-text.js!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js ***!
  \***************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/babel-loader/lib/index.js?!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/babel-loader/lib/index.js?!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js\":\n/*!***********************************************************************************************************************************!*\\\n  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js ***!\n  \\***********************************************************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {const context = __webpack_require__(/*! ./tw-extension-worker-context */ \"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\");\n\nconst jQuery = __webpack_require__(/*! ./tw-jquery-shim */ \"./node_modules/scratch-vm/src/extension-support/tw-jquery-shim.js\");\n\nglobal.$ = jQuery;\nglobal.jQuery = jQuery;\nconst id = window.__WRAPPED_IFRAME_ID__;\ncontext.isWorker = false;\ncontext.centralDispatchService = {\n  postMessage(message, transfer) {\n    const data = {\n      vmIframeId: id,\n      message\n    };\n\n    if (transfer) {\n      window.parent.postMessage(data, '*', transfer);\n    } else {\n      window.parent.postMessage(data, '*');\n    }\n  }\n\n};\n\n__webpack_require__(/*! ./extension-worker */ \"./node_modules/scratch-vm/src/extension-support/extension-worker.js\");\n\nwindow.parent.postMessage({\n  vmIframeId: id,\n  ready: true\n}, '*');\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/microee/index.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/microee/index.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nfunction M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/common/filter.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/minilog/lib/common/filter.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// default filter\nvar Transform = __webpack_require__(/*! ./transform.js */ \"./node_modules/minilog/lib/common/transform.js\");\n\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\n\nTransform.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function(name, level) {\n  this._white.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function(name, level) {\n  this._black.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\nFilter.prototype.clear = function() {\n  this._white = [];\n  this._black = [];\n  return this;\n};\n\nfunction test(rule, name) {\n  // use .test for RegExps\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\n};\n\nFilter.prototype.test = function(name, level) {\n  var i, len = Math.max(this._white.length, this._black.length);\n  for(i = 0; i < len; i++) {\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\n\nFilter.prototype.write = function(name, level, args) {\n  if(!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\n\nmodule.exports = Filter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/common/minilog.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/minilog/lib/common/minilog.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ./transform.js */ \"./node_modules/minilog/lib/common/transform.js\"),\n    Filter = __webpack_require__(/*! ./filter.js */ \"./node_modules/minilog/lib/common/filter.js\");\n\nvar log = new Transform(),\n    slice = Array.prototype.slice;\n\nexports = module.exports = function create(name) {\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\n  o.suggest = exports.suggest;\n  o.format = log.format;\n  return o;\n};\n\n// filled in separately\nexports.defaultBackend = exports.defaultFormatter = null;\n\nexports.pipe = function(dest) {\n  return log.pipe(dest);\n};\n\nexports.end = exports.unpipe = exports.disable = function(from) {\n  return log.unpipe(from);\n};\n\nexports.Transform = Transform;\nexports.Filter = Filter;\n// this is the default filter that's applied when .enable() is called normally\n// you can bypass it completely and set up your own pipes\nexports.suggest = new Filter();\n\nexports.enable = function() {\n  if(exports.defaultFormatter) {\n    return log.pipe(exports.suggest) // filter\n              .pipe(exports.defaultFormatter) // formatter\n              .pipe(exports.defaultBackend); // backend\n  }\n  return log.pipe(exports.suggest) // filter\n            .pipe(exports.defaultBackend); // formatter\n};\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/common/transform.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/minilog/lib/common/transform.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar microee = __webpack_require__(/*! microee */ \"./node_modules/microee/index.js\");\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/array.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/minilog/lib/web/array.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \"./node_modules/minilog/lib/common/transform.js\"),\n    cache = [ ];\n\nvar logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  cache.push([ name, level, args ]);\n};\n\n// utility functions\nlogger.get = function() { return cache; };\nlogger.empty = function() { cache = []; };\n\nmodule.exports = logger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/console.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/minilog/lib/web/console.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \"./node_modules/minilog/lib/common/transform.js\");\n\nvar newlines = /\\n+$/,\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var i = args.length-1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if(console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if(JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if(args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for(i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch(e) {}\n    console.log(args.join(' '));\n  }\n};\n\nlogger.formatters = ['color', 'minilog'];\nlogger.color = __webpack_require__(/*! ./formatters/color.js */ \"./node_modules/minilog/lib/web/formatters/color.js\");\nlogger.minilog = __webpack_require__(/*! ./formatters/minilog.js */ \"./node_modules/minilog/lib/web/formatters/minilog.js\");\n\nmodule.exports = logger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/formatters/color.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/minilog/lib/web/formatters/color.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ../../common/transform.js */ \"./node_modules/minilog/lib/common/transform.js\"),\n    color = __webpack_require__(/*! ./util.js */ \"./node_modules/minilog/lib/web/formatters/util.js\");\n\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/formatters/minilog.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/minilog/lib/web/formatters/minilog.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ../../common/transform.js */ \"./node_modules/minilog/lib/common/transform.js\"),\n    color = __webpack_require__(/*! ./util.js */ \"./node_modules/minilog/lib/web/formatters/util.js\"),\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n\n  var subset = [], i = 0;\n  if(level != 'info') {\n    for(; i < args.length; i++) {\n      if(typeof args[i] != 'string') break;\n    }\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\n  } else {\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/formatters/util.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/minilog/lib/web/formatters/util.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/index.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/minilog/lib/web/index.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Minilog = __webpack_require__(/*! ../common/minilog.js */ \"./node_modules/minilog/lib/common/minilog.js\");\n\nvar oldEnable = Minilog.enable,\n    oldDisable = Minilog.disable,\n    isChrome = (typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent)),\n    console = __webpack_require__(/*! ./console.js */ \"./node_modules/minilog/lib/web/console.js\");\n\n// Use a more capable logging backend if on Chrome\nMinilog.defaultBackend = (isChrome ? console.minilog : console);\n\n// apply enable inputs from localStorage and from the URL\nif(typeof window != 'undefined') {\n  try {\n    Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));\n  } catch(e) {}\n  if(window.location && window.location.search) {\n    var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);\n    match && Minilog.enable(decodeURIComponent(match[1]));\n  }\n}\n\n// Make enable also add to localStorage\nMinilog.enable = function() {\n  oldEnable.call(Minilog, true);\n  try { window.localStorage['minilogSettings'] = JSON.stringify(true); } catch(e) {}\n  return this;\n};\n\nMinilog.disable = function() {\n  oldDisable.call(Minilog);\n  try { delete window.localStorage.minilogSettings; } catch(e) {}\n  return this;\n};\n\nexports = module.exports = Minilog;\n\nexports.backends = {\n  array: __webpack_require__(/*! ./array.js */ \"./node_modules/minilog/lib/web/array.js\"),\n  browser: Minilog.defaultBackend,\n  localStorage: __webpack_require__(/*! ./localstorage.js */ \"./node_modules/minilog/lib/web/localstorage.js\"),\n  jQuery: __webpack_require__(/*! ./jquery_simple.js */ \"./node_modules/minilog/lib/web/jquery_simple.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/jquery_simple.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/minilog/lib/web/jquery_simple.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \"./node_modules/minilog/lib/common/transform.js\");\n\nvar cid = new Date().valueOf().toString(36);\n\nfunction AjaxLogger(options) {\n  this.url = options.url || '';\n  this.cache = [];\n  this.timer = null;\n  this.interval = options.interval || 30*1000;\n  this.enabled = true;\n  this.jQuery = window.jQuery;\n  this.extras = {};\n}\n\nTransform.mixin(AjaxLogger);\n\nAjaxLogger.prototype.write = function(name, level, args) {\n  if(!this.timer) { this.init(); }\n  this.cache.push([name, level].concat(args));\n};\n\nAjaxLogger.prototype.init = function() {\n  if(!this.enabled || !this.jQuery) return;\n  var self = this;\n  this.timer = setTimeout(function() {\n    var i, logs = [], ajaxData, url = self.url;\n    if(self.cache.length == 0) return self.init();\n    // Test each log line and only log the ones that are valid (e.g. don't have circular references).\n    // Slight performance hit but benefit is we log all valid lines.\n    for(i = 0; i < self.cache.length; i++) {\n      try {\n        JSON.stringify(self.cache[i]);\n        logs.push(self.cache[i]);\n      } catch(e) { }\n    }\n    if(self.jQuery.isEmptyObject(self.extras)) {\n        ajaxData = JSON.stringify({ logs: logs });\n        url = self.url + '?client_id=' + cid;\n    } else {\n        ajaxData = JSON.stringify(self.jQuery.extend({logs: logs}, self.extras));\n    }\n\n    self.jQuery.ajax(url, {\n      type: 'POST',\n      cache: false,\n      processData: false,\n      data: ajaxData,\n      contentType: 'application/json',\n      timeout: 10000\n    }).success(function(data, status, jqxhr) {\n      if(data.interval) {\n        self.interval = Math.max(1000, data.interval);\n      }\n    }).error(function() {\n      self.interval = 30000;\n    }).always(function() {\n      self.init();\n    });\n    self.cache = [];\n  }, this.interval);\n};\n\nAjaxLogger.prototype.end = function() {};\n\n// wait until jQuery is defined. Useful if you don't control the load order.\nAjaxLogger.jQueryWait = function(onDone) {\n  if(typeof window !== 'undefined' && (window.jQuery || window.$)) {\n    return onDone(window.jQuery || window.$);\n  } else if (typeof window !== 'undefined') {\n    setTimeout(function() { AjaxLogger.jQueryWait(onDone); }, 200);\n  }\n};\n\nmodule.exports = AjaxLogger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/minilog/lib/web/localstorage.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/minilog/lib/web/localstorage.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \"./node_modules/minilog/lib/common/transform.js\"),\n    cache = false;\n\nvar logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  if(typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;\n  try {\n    if(!cache) { cache = (window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : []); }\n    cache.push([ new Date().toString(), name, level, args ]);\n    window.localStorage.minilog = JSON.stringify(cache);\n  } catch(e) {}\n};\n\nmodule.exports = logger;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/dispatch/shared-dispatch.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/dispatch/shared-dispatch.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst log = __webpack_require__(/*! ../util/log */ \"./node_modules/scratch-vm/src/util/log.js\");\n/**\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\n * @property {string} service - the name of the service to be called\n * @property {string} method - the name of the method to be called\n * @property {Array|undefined} args - the arguments to be passed to the method\n */\n\n/**\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\n * @property {*} responseId - a copy of the response ID from the call which generated this response\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\n */\n\n/**\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\n * Any message to the dispatch system.\n */\n\n/**\n * The SharedDispatch class is responsible for dispatch features shared by\n * {@link CentralDispatch} and {@link WorkerDispatch}.\n */\n\n\nclass SharedDispatch {\n  constructor() {\n    /**\n     * List of callback registrations for promises waiting for a response from a call to a service on another\n     * worker. A callback registration is an array of [resolve,reject] Promise functions.\n     * Calls to local services don't enter this list.\n     * @type {Array.<Function[]>}\n     */\n    this.callbacks = [];\n    /**\n     * The next response ID to be used.\n     * @type {int}\n     */\n\n    this.nextResponseId = 0;\n  }\n  /**\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n   * transferred to the worker, and they should not be used after this call.\n   * @example\n   *      dispatcher.call('vm', 'setData', 'cat', 42);\n   *      // this finds the worker for the 'vm' service, then on that worker calls:\n   *      vm.setData('cat', 42);\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n\n\n  call(service, method, ...args) {\n    return this.transferCall(service, method, null, ...args);\n  }\n  /**\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n   * transferred to the worker, and they should not be used after this call.\n   * @example\n   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);\n   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:\n   *      vm.setData('cat', myArrayBuffer);\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n\n\n  transferCall(service, method, transfer, ...args) {\n    try {\n      const {\n        provider,\n        isRemote\n      } = this._getServiceProvider(service);\n\n      if (provider) {\n        if (isRemote) {\n          return this._remoteTransferCall(provider, service, method, transfer, ...args);\n        }\n\n        const result = provider[method].apply(provider, args);\n        return Promise.resolve(result);\n      }\n\n      return Promise.reject(new Error(\"Service not found: \".concat(service)));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Check if a particular service lives on another worker.\n   * @param {string} service - the service to check.\n   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.\n   * @private\n   */\n\n\n  _isRemoteService(service) {\n    return this._getServiceProvider(service).isRemote;\n  }\n  /**\n   * Like {@link call}, but force the call to be posted through a particular communication channel.\n   * @param {object} provider - send the call through this object's `postMessage` function.\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n\n\n  _remoteCall(provider, service, method, ...args) {\n    return this._remoteTransferCall(provider, service, method, null, ...args);\n  }\n  /**\n   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.\n   * @param {object} provider - send the call through this object's `postMessage` function.\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n\n\n  _remoteTransferCall(provider, service, method, transfer, ...args) {\n    return new Promise((resolve, reject) => {\n      const responseId = this._storeCallbacks(resolve, reject);\n      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */\n      // tw: upstream's logic is broken\n      // Args is actually a 3 length list of [args, util, real block info]\n      // We only want to send args. The others will throw errors when they try to be cloned\n\n\n      if (args.length > 0 && typeof args[args.length - 1].func === 'function') {\n        args.pop();\n        args.pop();\n      }\n\n      if (transfer) {\n        provider.postMessage({\n          service,\n          method,\n          responseId,\n          args\n        }, transfer);\n      } else {\n        provider.postMessage({\n          service,\n          method,\n          responseId,\n          args\n        });\n      }\n    });\n  }\n  /**\n   * Store callback functions pending a response message.\n   * @param {Function} resolve - function to call if the service method returns.\n   * @param {Function} reject - function to call if the service method throws.\n   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.\n   * @protected\n   */\n\n\n  _storeCallbacks(resolve, reject) {\n    const responseId = this.nextResponseId++;\n    this.callbacks[responseId] = [resolve, reject];\n    return responseId;\n  }\n  /**\n   * Deliver call response from a worker. This should only be called as the result of a message from a worker.\n   * @param {int} responseId - the response ID of the callback set to call.\n   * @param {DispatchResponseMessage} message - the message containing the response value(s).\n   * @protected\n   */\n\n\n  _deliverResponse(responseId, message) {\n    try {\n      const [resolve, reject] = this.callbacks[responseId];\n      delete this.callbacks[responseId];\n\n      if (message.error) {\n        reject(message.error);\n      } else {\n        resolve(message.result);\n      }\n    } catch (e) {\n      log.error(\"Dispatch callback failed: \".concat(e));\n    }\n  }\n  /**\n   * Handle a message event received from a connected worker.\n   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.\n   * @param {MessageEvent} event - the message event to be handled.\n   * @protected\n   */\n\n\n  _onMessage(worker, event) {\n    /** @type {DispatchMessage} */\n    const message = event.data;\n    message.args = message.args || [];\n    let promise;\n\n    if (message.service) {\n      if (message.service === 'dispatch') {\n        promise = this._onDispatchMessage(worker, message);\n      } else {\n        promise = this.call(message.service, message.method, ...message.args);\n      }\n    } else if (typeof message.responseId === 'undefined') {\n      log.error(\"Dispatch caught malformed message from a worker: \".concat(JSON.stringify(event)));\n    } else {\n      this._deliverResponse(message.responseId, message);\n    }\n\n    if (promise) {\n      if (typeof message.responseId === 'undefined') {\n        log.error(\"Dispatch message missing required response ID: \".concat(JSON.stringify(event)));\n      } else {\n        promise.then(result => worker.postMessage({\n          responseId: message.responseId,\n          result\n        }), error => worker.postMessage({\n          responseId: message.responseId,\n          error: \"\".concat(error)\n        }));\n      }\n    }\n  }\n  /**\n   * Fetch the service provider object for a particular service name.\n   * @abstract\n   * @param {string} service - the name of the service to look up\n   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n   * @protected\n   */\n\n\n  _getServiceProvider(service) {\n    throw new Error(\"Could not get provider for \".concat(service, \": _getServiceProvider not implemented\"));\n  }\n  /**\n   * Handle a call message sent to the dispatch service itself\n   * @abstract\n   * @param {Worker} worker - the worker which sent the message.\n   * @param {DispatchCallMessage} message - the message to be handled.\n   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n   * @private\n   */\n\n\n  _onDispatchMessage(worker, message) {\n    throw new Error(\"Unimplemented dispatch message handler cannot handle \".concat(message.method, \" method\"));\n  }\n\n}\n\nmodule.exports = SharedDispatch;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/dispatch/worker-dispatch.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/dispatch/worker-dispatch.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst SharedDispatch = __webpack_require__(/*! ./shared-dispatch */ \"./node_modules/scratch-vm/src/dispatch/shared-dispatch.js\");\n\nconst log = __webpack_require__(/*! ../util/log */ \"./node_modules/scratch-vm/src/util/log.js\");\n\nconst {\n  centralDispatchService\n} = __webpack_require__(/*! ../extension-support/tw-extension-worker-context */ \"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\");\n/**\n * This class provides a Worker with the means to participate in the message dispatch system managed by CentralDispatch.\n * From any context in the messaging system, the dispatcher's \"call\" method can call any method on any \"service\"\n * provided in any participating context. The dispatch system will forward function arguments and return values across\n * worker boundaries as needed.\n * @see {CentralDispatch}\n */\n\n\nclass WorkerDispatch extends SharedDispatch {\n  constructor() {\n    super();\n    /**\n     * This promise will be resolved when we have successfully connected to central dispatch.\n     * @type {Promise}\n     * @see {waitForConnection}\n     * @private\n     */\n\n    this._connectionPromise = new Promise(resolve => {\n      this._onConnect = resolve;\n    });\n    /**\n     * Map of service name to local service provider.\n     * If a service is not listed here, it is assumed to be provided by another context (another Worker or the main\n     * thread).\n     * @see {setService}\n     * @type {object}\n     */\n\n    this.services = {};\n    this._onMessage = this._onMessage.bind(this, centralDispatchService);\n\n    if (typeof self !== 'undefined') {\n      self.onmessage = this._onMessage;\n    }\n  }\n  /**\n   * @returns {Promise} a promise which will resolve upon connection to central dispatch. If you need to make a call\n   * immediately on \"startup\" you can attach a 'then' to this promise.\n   * @example\n   *      dispatch.waitForConnection.then(() => {\n   *          dispatch.call('myService', 'hello');\n   *      })\n   */\n\n\n  get waitForConnection() {\n    return this._connectionPromise;\n  }\n  /**\n   * Set a local object as the global provider of the specified service.\n   * WARNING: Any method on the provider can be called from any worker within the dispatch system.\n   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.\n   * @param {object} provider - a local object which provides this service.\n   * @returns {Promise} - a promise which will resolve once the service is registered.\n   */\n\n\n  setService(service, provider) {\n    if (this.services.hasOwnProperty(service)) {\n      log.warn(\"Worker dispatch replacing existing service provider for \".concat(service));\n    }\n\n    this.services[service] = provider;\n    return this.waitForConnection.then(() => this._remoteCall(centralDispatchService, 'dispatch', 'setService', service));\n  }\n  /**\n   * Fetch the service provider object for a particular service name.\n   * @override\n   * @param {string} service - the name of the service to look up\n   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n   * @protected\n   */\n\n\n  _getServiceProvider(service) {\n    // if we don't have a local service by this name, contact central dispatch by calling `postMessage` on self\n    const provider = this.services[service];\n    return {\n      provider: provider || centralDispatchService,\n      isRemote: !provider\n    };\n  }\n  /**\n   * Handle a call message sent to the dispatch service itself\n   * @override\n   * @param {Worker} worker - the worker which sent the message.\n   * @param {DispatchCallMessage} message - the message to be handled.\n   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n   * @protected\n   */\n\n\n  _onDispatchMessage(worker, message) {\n    let promise;\n\n    switch (message.method) {\n      case 'handshake':\n        promise = this._onConnect();\n        break;\n\n      case 'terminate':\n        // Don't close until next tick, after sending confirmation back\n        setTimeout(() => self.close(), 0);\n        promise = Promise.resolve();\n        break;\n\n      default:\n        log.error(\"Worker dispatch received message for unknown method: \".concat(message.method));\n    }\n\n    return promise;\n  }\n\n}\n\nmodule.exports = new WorkerDispatch();\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/argument-type.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/argument-type.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Block argument types\n * @enum {string}\n */\nconst ArgumentType = {\n  /**\n   * Numeric value with angle picker\n   */\n  ANGLE: 'angle',\n\n  /**\n   * Boolean value with hexagonal placeholder\n   */\n  BOOLEAN: 'Boolean',\n\n  /**\n   * Numeric value with color picker\n   */\n  COLOR: 'color',\n\n  /**\n   * Numeric value with text field\n   */\n  NUMBER: 'number',\n\n  /**\n   * String value with text field\n   */\n  STRING: 'string',\n\n  /**\n   * String value with matrix field\n   */\n  MATRIX: 'matrix',\n\n  /**\n   * MIDI note number with note picker (piano) field\n   */\n  NOTE: 'note',\n\n  /**\n   * Inline image on block (as part of the label)\n   */\n  IMAGE: 'image',\n\n  /**\n   * Name of costume in the current target\n   */\n  COSTUME: 'costume',\n\n  /**\n   * Name of sound in the current target\n   */\n  SOUND: 'sound'\n};\nmodule.exports = ArgumentType;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/block-type.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/block-type.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Types of block\n * @enum {string}\n */\nconst BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  BOOLEAN: 'Boolean',\n\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  BUTTON: 'button',\n\n  /**\n   * Command block\n   */\n  COMMAND: 'command',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  CONDITIONAL: 'conditional',\n\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  EVENT: 'event',\n\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  HAT: 'hat',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  LOOP: 'loop',\n\n  /**\n   * General reporter with numeric or string value\n   */\n  REPORTER: 'reporter'\n};\nmodule.exports = BlockType;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/extension-worker.js\":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/extension-worker.js ***!\n  \\***************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/* eslint-env worker */\nconst ScratchCommon = __webpack_require__(/*! ./tw-extension-api-common */ \"./node_modules/scratch-vm/src/extension-support/tw-extension-api-common.js\");\n\nconst dispatch = __webpack_require__(/*! ../dispatch/worker-dispatch */ \"./node_modules/scratch-vm/src/dispatch/worker-dispatch.js\");\n\nconst log = __webpack_require__(/*! ../util/log */ \"./node_modules/scratch-vm/src/util/log.js\");\n\nconst {\n  isWorker\n} = __webpack_require__(/*! ./tw-extension-worker-context */ \"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\");\n\nconst loadScripts = url => {\n  if (isWorker) {\n    importScripts(url);\n  } else {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n\n      script.onload = () => resolve();\n\n      script.onerror = () => {\n        reject(new Error(\"Error in sandboxed script: \".concat(url, \". Check the console for more information.\")));\n      };\n\n      script.src = url;\n      document.body.appendChild(script);\n    });\n  }\n};\n\nclass ExtensionWorker {\n  constructor() {\n    this.nextExtensionId = 0;\n    this.initialRegistrations = [];\n    this.firstRegistrationPromise = new Promise(resolve => {\n      this.firstRegistrationCallback = resolve;\n    });\n    dispatch.waitForConnection.then(() => {\n      dispatch.call('extensions', 'allocateWorker').then(async x => {\n        const [id, extension] = x;\n        this.workerId = id;\n\n        try {\n          await loadScripts(extension);\n          await this.firstRegistrationPromise;\n          const initialRegistrations = this.initialRegistrations;\n          this.initialRegistrations = null;\n          Promise.all(initialRegistrations).then(() => dispatch.call('extensions', 'onWorkerInit', id));\n        } catch (e) {\n          log.error(e);\n          dispatch.call('extensions', 'onWorkerInit', id, \"\".concat(e));\n        }\n      });\n    });\n    this.extensions = [];\n  }\n\n  register(extensionObject) {\n    const extensionId = this.nextExtensionId++;\n    this.extensions.push(extensionObject);\n    const serviceName = \"extension.\".concat(this.workerId, \".\").concat(extensionId);\n    const promise = dispatch.setService(serviceName, extensionObject).then(() => dispatch.call('extensions', 'registerExtensionService', serviceName));\n\n    if (this.initialRegistrations) {\n      this.firstRegistrationCallback();\n      this.initialRegistrations.push(promise);\n    }\n\n    return promise;\n  }\n\n}\n\nglobal.Scratch = global.Scratch || {};\nObject.assign(global.Scratch, ScratchCommon, {\n  canFetch: () => Promise.resolve(true),\n  fetch: function (_fetch) {\n    function fetch(_x, _x2) {\n      return _fetch.apply(this, arguments);\n    }\n\n    fetch.toString = function () {\n      return _fetch.toString();\n    };\n\n    return fetch;\n  }((url, options) => fetch(url, options)),\n  canOpenWindow: () => Promise.resolve(false),\n  openWindow: () => Promise.reject(new Error('Scratch.openWindow not supported in sandboxed extensions')),\n  canRedirect: () => Promise.resolve(false),\n  redirect: () => Promise.reject(new Error('Scratch.redirect not supported in sandboxed extensions'))\n});\n/**\n * Expose only specific parts of the worker to extensions.\n */\n\nconst extensionWorker = new ExtensionWorker();\nglobal.Scratch.extensions = {\n  register: extensionWorker.register.bind(extensionWorker)\n};\nglobal.ScratchExtensions = __webpack_require__(/*! ./tw-scratchx-compatibility-layer */ \"./node_modules/scratch-vm/src/extension-support/tw-scratchx-compatibility-layer.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/target-type.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/target-type.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Default types of Target supported by the VM\n * @enum {string}\n */\nconst TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  SPRITE: 'sprite',\n\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  STAGE: 'stage'\n};\nmodule.exports = TargetType;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/tw-extension-api-common.js\":\n/*!**********************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-extension-api-common.js ***!\n  \\**********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst ArgumentType = __webpack_require__(/*! ./argument-type */ \"./node_modules/scratch-vm/src/extension-support/argument-type.js\");\n\nconst BlockType = __webpack_require__(/*! ./block-type */ \"./node_modules/scratch-vm/src/extension-support/block-type.js\");\n\nconst TargetType = __webpack_require__(/*! ./target-type */ \"./node_modules/scratch-vm/src/extension-support/target-type.js\");\n\nconst Cast = __webpack_require__(/*! ../util/cast */ \"./node_modules/scratch-vm/src/util/cast.js\");\n\nconst Scratch = {\n  ArgumentType,\n  BlockType,\n  TargetType,\n  Cast\n};\nmodule.exports = Scratch;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\":\n/*!**************************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js ***!\n  \\**************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  isWorker: true,\n  // centralDispatchService is the object to call postMessage() on to send a message to parent.\n  centralDispatchService: self\n};\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/tw-jquery-shim.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-jquery-shim.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * @fileoverview\n * Many ScratchX extensions require jQuery to do things like loading scripts and making requests.\n * The real jQuery is pretty large and we'd rather not bring in everything, so this file reimplements\n * small stubs of a few jQuery methods.\n * It's just supposed to be enough to make existing ScratchX extensions work, nothing more.\n */\nconst log = __webpack_require__(/*! ../util/log */ \"./node_modules/scratch-vm/src/util/log.js\");\n\nconst jQuery = () => {\n  throw new Error('Not implemented');\n};\n\njQuery.getScript = (src, callback) => {\n  const script = document.createElement('script');\n  script.src = src;\n\n  if (callback) {\n    // We don't implement callback arguments.\n    script.onload = () => callback();\n  }\n\n  document.body.appendChild(script);\n};\n/**\n * @param {Record<string, any>|undefined} obj\n * @returns {URLSearchParams}\n */\n\n\nconst objectToQueryString = obj => {\n  const params = new URLSearchParams();\n\n  if (obj) {\n    for (const key of Object.keys(obj)) {\n      params.set(key, obj[key]);\n    }\n  }\n\n  return params;\n};\n\nlet jsonpCallback = 0;\n\njQuery.ajax = async (arg1, arg2) => {\n  let options = {};\n\n  if (arg1 && arg2) {\n    options = arg2;\n    options.url = arg1;\n  } else if (arg1) {\n    options = arg1;\n  }\n\n  const urlParameters = objectToQueryString(options.data);\n\n  const getFinalURL = () => {\n    const query = urlParameters.toString();\n    let url = options.url;\n\n    if (query) {\n      url += \"?\".concat(query);\n    } // Forcibly upgrade all HTTP requests to HTTPS so that they don't error on HTTPS sites\n    // All the extensions we care about work fine with this\n\n\n    if (url.startsWith('http://')) {\n      url = url.replace('http://', 'https://');\n    }\n\n    return url;\n  };\n\n  const successCallback = result => {\n    if (options.success) {\n      options.success(result);\n    }\n  };\n\n  const errorCallback = error => {\n    log.error(error);\n\n    if (options.error) {\n      // The error object we provide here might not match what jQuery provides but it's enough to\n      // prevent extensions from throwing errors trying to access properties.\n      options.error(error);\n    }\n  };\n\n  try {\n    if (options.dataType === 'jsonp') {\n      const callbackName = \"_jsonp_callback\".concat(jsonpCallback++);\n\n      global[callbackName] = data => {\n        delete global[callbackName];\n        successCallback(data);\n      };\n\n      const callbackParameterName = options.jsonp || 'callback';\n      urlParameters.set(callbackParameterName, callbackName);\n      jQuery.getScript(getFinalURL());\n      return;\n    }\n\n    if (options.dataType === 'script') {\n      jQuery.getScript(getFinalURL(), successCallback);\n      return;\n    }\n\n    const res = await fetch(getFinalURL(), {\n      headers: options.headers\n    }); // dataType defaults to \"Intelligent Guess (xml, json, script, or html)\"\n    // It happens that all the ScratchX extensions we care about either set dataType to \"json\" or\n    // leave it blank and implicitly request JSON, so this works good enough for now.\n\n    successCallback(await res.json());\n  } catch (e) {\n    errorCallback(e);\n  }\n};\n\nmodule.exports = jQuery;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/tw-scratchx-compatibility-layer.js\":\n/*!******************************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-scratchx-compatibility-layer.js ***!\n  \\******************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// ScratchX API Documentation: https://github.com/LLK/scratchx/wiki/\n// Global Scratch API from extension-worker.js\n\n/* globals Scratch */\nconst ArgumentType = __webpack_require__(/*! ./argument-type */ \"./node_modules/scratch-vm/src/extension-support/argument-type.js\");\n\nconst BlockType = __webpack_require__(/*! ./block-type */ \"./node_modules/scratch-vm/src/extension-support/block-type.js\");\n\nconst {\n  argumentIndexToId,\n  generateExtensionId\n} = __webpack_require__(/*! ./tw-scratchx-utilities */ \"./node_modules/scratch-vm/src/extension-support/tw-scratchx-utilities.js\");\n/**\n * @typedef ScratchXDescriptor\n * @property {unknown[][]} blocks\n * @property {Record<string, unknown[]>} [menus]\n * @property {string} [url]\n * @property {string} [displayName]\n */\n\n/**\n * @typedef ScratchXStatus\n * @property {0|1|2} status 0 is red/error, 1 is yellow/not ready, 2 is green/ready\n * @property {string} msg\n */\n\n\nconst parseScratchXBlockType = type => {\n  if (type === '' || type === ' ' || type === 'w') {\n    return {\n      type: BlockType.COMMAND,\n      async: type === 'w'\n    };\n  }\n\n  if (type === 'r' || type === 'R') {\n    return {\n      type: BlockType.REPORTER,\n      async: type === 'R'\n    };\n  }\n\n  if (type === 'b') {\n    return {\n      type: BlockType.BOOLEAN,\n      // ScratchX docs don't seem to mention boolean reporters that wait\n      async: false\n    };\n  }\n\n  if (type === 'h') {\n    return {\n      type: BlockType.HAT,\n      async: false\n    };\n  }\n\n  throw new Error(\"Unknown ScratchX block type: \".concat(type));\n};\n\nconst isScratchCompatibleValue = v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean';\n/**\n * @param {string} argument ScratchX argument with leading % removed.\n * @param {unknown} defaultValue Default value, if any\n */\n\n\nconst parseScratchXArgument = (argument, defaultValue) => {\n  const result = {};\n  const hasDefaultValue = isScratchCompatibleValue(defaultValue);\n\n  if (hasDefaultValue) {\n    result.defaultValue = defaultValue;\n  } // TODO: ScratchX docs don't mention support for boolean arguments?\n\n\n  if (argument === 's') {\n    result.type = ArgumentType.STRING;\n\n    if (!hasDefaultValue) {\n      result.defaultValue = '';\n    }\n  } else if (argument === 'n') {\n    result.type = ArgumentType.NUMBER;\n\n    if (!hasDefaultValue) {\n      result.defaultValue = 0;\n    }\n  } else if (argument[0] === 'm') {\n    result.type = ArgumentType.STRING;\n    const split = argument.split(/\\.|:/);\n    const menuName = split[1];\n    result.menu = menuName;\n  } else {\n    throw new Error(\"Unknown ScratchX argument type: \".concat(argument));\n  }\n\n  return result;\n};\n\nconst wrapScratchXFunction = (originalFunction, argumentCount, async) => args => {\n  // Convert Scratch 3's argument object to an argument list expected by ScratchX\n  const argumentList = [];\n\n  for (let i = 0; i < argumentCount; i++) {\n    argumentList.push(args[argumentIndexToId(i)]);\n  }\n\n  if (async) {\n    return new Promise(resolve => {\n      originalFunction(...argumentList, resolve);\n    });\n  }\n\n  return originalFunction(...argumentList);\n};\n/**\n * @param {string} name\n * @param {ScratchXDescriptor} descriptor\n * @param {Record<string, () => unknown>} functions\n */\n\n\nconst convert = (name, descriptor, functions) => {\n  const extensionId = generateExtensionId(name);\n  const info = {\n    id: extensionId,\n    name: descriptor.displayName || name,\n    blocks: [],\n    color1: '#4a4a5e',\n    color2: '#31323f',\n    color3: '#191a21'\n  };\n  const scratch3Extension = {\n    getInfo: () => info,\n    _getStatus: functions._getStatus\n  };\n\n  if (descriptor.url) {\n    info.docsURI = descriptor.url;\n  }\n\n  for (const blockDescriptor of descriptor.blocks) {\n    if (blockDescriptor.length === 1) {\n      // Separator\n      info.blocks.push('---');\n      continue;\n    }\n\n    const scratchXBlockType = blockDescriptor[0];\n    const blockText = blockDescriptor[1];\n    const functionName = blockDescriptor[2];\n    const defaultArgumentValues = blockDescriptor.slice(3);\n    let scratchText = '';\n    const argumentInfo = [];\n    const blockTextParts = blockText.split(/%([\\w.:]+)/g);\n\n    for (let i = 0; i < blockTextParts.length; i++) {\n      const part = blockTextParts[i];\n      const isArgument = i % 2 === 1;\n\n      if (isArgument) {\n        parseScratchXArgument(part);\n        const argumentIndex = Math.floor(i / 2).toString();\n        const argumentDefaultValue = defaultArgumentValues[argumentIndex];\n        const argumentId = argumentIndexToId(argumentIndex);\n        argumentInfo[argumentId] = parseScratchXArgument(part, argumentDefaultValue);\n        scratchText += \"[\".concat(argumentId, \"]\");\n      } else {\n        scratchText += part;\n      }\n    }\n\n    const scratch3BlockType = parseScratchXBlockType(scratchXBlockType);\n    const blockInfo = {\n      opcode: functionName,\n      blockType: scratch3BlockType.type,\n      text: scratchText,\n      arguments: argumentInfo\n    };\n    info.blocks.push(blockInfo);\n    const originalFunction = functions[functionName];\n    const argumentCount = argumentInfo.length;\n    scratch3Extension[functionName] = wrapScratchXFunction(originalFunction, argumentCount, scratch3BlockType.async);\n  }\n\n  const menus = descriptor.menus;\n\n  if (menus) {\n    const scratch3Menus = {};\n\n    for (const menuName of Object.keys(menus) || {}) {\n      const menuItems = menus[menuName];\n      const menuInfo = {\n        items: menuItems\n      };\n      scratch3Menus[menuName] = menuInfo;\n    }\n\n    info.menus = scratch3Menus;\n  }\n\n  return scratch3Extension;\n};\n\nconst extensionNameToExtension = new Map();\n\nconst register = (name, descriptor, functions) => {\n  const scratch3Extension = convert(name, descriptor, functions);\n  extensionNameToExtension.set(name, scratch3Extension);\n  Scratch.extensions.register(scratch3Extension);\n};\n/**\n * @param {string} extensionName\n * @returns {ScratchXStatus}\n */\n\n\nconst getStatus = extensionName => {\n  const extension = extensionNameToExtension.get(extensionName);\n\n  if (extension) {\n    return extension._getStatus();\n  }\n\n  return {\n    status: 0,\n    msg: 'does not exist'\n  };\n};\n\nmodule.exports = {\n  register,\n  getStatus,\n  // For tests\n  convert\n};\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/extension-support/tw-scratchx-utilities.js\":\n/*!********************************************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-scratchx-utilities.js ***!\n  \\********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * @fileoverview\n * General ScratchX-related utilities used in multiple places.\n * Changing these functions may break projects.\n */\n\n/**\n * @param {string} scratchXName\n * @returns {string}\n */\nconst generateExtensionId = scratchXName => {\n  const sanitizedName = scratchXName.replace(/[^a-z0-9]/gi, '').toLowerCase();\n  return \"sbx\".concat(sanitizedName);\n};\n/**\n * @param {number} i 0-indexed index of argument in list\n * @returns {string} Scratch 3 argument name\n */\n\n\nconst argumentIndexToId = i => i.toString();\n\nmodule.exports = {\n  generateExtensionId,\n  argumentIndexToId\n};\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/util/cast.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/util/cast.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst Color = __webpack_require__(/*! ../util/color */ \"./node_modules/scratch-vm/src/util/color.js\");\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\n/**\n * Used internally by compare()\n * @param {*} val A value that evaluates to 0 in JS string-to-number conversation such as empty string, 0, or tab.\n * @returns {boolean} True if the value should not be treated as the number zero.\n */\n\n\nconst isNotActuallyZero = val => {\n  if (typeof val !== 'string') return false;\n\n  for (let i = 0; i < val.length; i++) {\n    const code = val.charCodeAt(i); // '0'.charCodeAt(0) === 48\n    // '\\t'.charCodeAt(0) === 9\n    // We include tab for compatibility with scratch-www's broken trim() polyfill.\n    // https://github.com/TurboWarp/scratch-vm/issues/115\n    // https://scratch.mit.edu/projects/788261699/\n\n    if (code === 48 || code === 9) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nclass Cast {\n  /**\n   * Scratch cast to number.\n   * Treats NaN as 0.\n   * In Scratch 2.0, this is captured by `interp.numArg.`\n   * @param {*} value Value to cast to number.\n   * @return {number} The Scratch-casted number value.\n   */\n  static toNumber(value) {\n    // If value is already a number we don't need to coerce it with\n    // Number().\n    if (typeof value === 'number') {\n      // Scratch treats NaN as 0, when needed as a number.\n      // E.g., 0 + NaN -> 0.\n      if (Number.isNaN(value)) {\n        return 0;\n      }\n\n      return value;\n    }\n\n    const n = Number(value);\n\n    if (Number.isNaN(n)) {\n      // Scratch treats NaN as 0, when needed as a number.\n      // E.g., 0 + NaN -> 0.\n      return 0;\n    }\n\n    return n;\n  }\n  /**\n   * Scratch cast to boolean.\n   * In Scratch 2.0, this is captured by `interp.boolArg.`\n   * Treats some string values differently from JavaScript.\n   * @param {*} value Value to cast to boolean.\n   * @return {boolean} The Scratch-casted boolean value.\n   */\n\n\n  static toBoolean(value) {\n    // Already a boolean?\n    if (typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      // These specific strings are treated as false in Scratch.\n      if (value === '' || value === '0' || value.toLowerCase() === 'false') {\n        return false;\n      } // All other strings treated as true.\n\n\n      return true;\n    } // Coerce other values and numbers.\n\n\n    return Boolean(value);\n  }\n  /**\n   * Scratch cast to string.\n   * @param {*} value Value to cast to string.\n   * @return {string} The Scratch-casted string value.\n   */\n\n\n  static toString(value) {\n    return String(value);\n  }\n  /**\n   * Cast any Scratch argument to an RGB color array to be used for the renderer.\n   * @param {*} value Value to convert to RGB color array.\n   * @return {Array.<number>} [r,g,b], values between 0-255.\n   */\n\n\n  static toRgbColorList(value) {\n    const color = Cast.toRgbColorObject(value);\n    return [color.r, color.g, color.b];\n  }\n  /**\n   * Cast any Scratch argument to an RGB color object to be used for the renderer.\n   * @param {*} value Value to convert to RGB color object.\n   * @return {RGBOject} [r,g,b], values between 0-255.\n   */\n\n\n  static toRgbColorObject(value) {\n    let color;\n\n    if (typeof value === 'string' && value.substring(0, 1) === '#') {\n      color = Color.hexToRgb(value); // If the color wasn't *actually* a hex color, cast to black\n\n      if (!color) color = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n      };\n    } else {\n      color = Color.decimalToRgb(Cast.toNumber(value));\n    }\n\n    return color;\n  }\n  /**\n   * Determine if a Scratch argument is a white space string (or null / empty).\n   * @param {*} val value to check.\n   * @return {boolean} True if the argument is all white spaces or null / empty.\n   */\n\n\n  static isWhiteSpace(val) {\n    return val === null || typeof val === 'string' && val.trim().length === 0;\n  }\n  /**\n   * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n   * In Scratch 2.0, this is captured by `interp.compare.`\n   * @param {*} v1 First value to compare.\n   * @param {*} v2 Second value to compare.\n   * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n   */\n\n\n  static compare(v1, v2) {\n    let n1 = Number(v1);\n    let n2 = Number(v2);\n\n    if (n1 === 0 && isNotActuallyZero(v1)) {\n      n1 = NaN;\n    } else if (n2 === 0 && isNotActuallyZero(v2)) {\n      n2 = NaN;\n    }\n\n    if (isNaN(n1) || isNaN(n2)) {\n      // At least one argument can't be converted to a number.\n      // Scratch compares strings as case insensitive.\n      const s1 = String(v1).toLowerCase();\n      const s2 = String(v2).toLowerCase();\n\n      if (s1 < s2) {\n        return -1;\n      } else if (s1 > s2) {\n        return 1;\n      }\n\n      return 0;\n    } // Handle the special case of Infinity\n\n\n    if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {\n      return 0;\n    } // Compare as numbers.\n\n\n    return n1 - n2;\n  }\n  /**\n   * Determine if a Scratch argument number represents a round integer.\n   * @param {*} val Value to check.\n   * @return {boolean} True if number looks like an integer.\n   */\n\n\n  static isInt(val) {\n    // Values that are already numbers.\n    if (typeof val === 'number') {\n      if (isNaN(val)) {\n        // NaN is considered an integer.\n        return true;\n      } // True if it's \"round\" (e.g., 2.0 and 2).\n\n\n      return val === Math.floor(val);\n    } else if (typeof val === 'boolean') {\n      // `True` and `false` always represent integer after Scratch cast.\n      return true;\n    } else if (typeof val === 'string') {\n      // If it contains a decimal point, don't consider it an int.\n      return val.indexOf('.') < 0;\n    }\n\n    return false;\n  }\n\n  static get LIST_INVALID() {\n    return 'INVALID';\n  }\n\n  static get LIST_ALL() {\n    return 'ALL';\n  }\n  /**\n   * Compute a 1-based index into a list, based on a Scratch argument.\n   * Two special cases may be returned:\n   * LIST_ALL: if the block is referring to all of the items in the list.\n   * LIST_INVALID: if the index was invalid in any way.\n   * @param {*} index Scratch arg, including 1-based numbers or special cases.\n   * @param {number} length Length of the list.\n   * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n   * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n   */\n\n\n  static toListIndex(index, length, acceptAll) {\n    if (typeof index !== 'number') {\n      if (index === 'all') {\n        return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n      }\n\n      if (index === 'last') {\n        if (length > 0) {\n          return length;\n        }\n\n        return Cast.LIST_INVALID;\n      } else if (index === 'random' || index === 'any') {\n        if (length > 0) {\n          return 1 + Math.floor(Math.random() * length);\n        }\n\n        return Cast.LIST_INVALID;\n      }\n    }\n\n    index = Math.floor(Cast.toNumber(index));\n\n    if (index < 1 || index > length) {\n      return Cast.LIST_INVALID;\n    }\n\n    return index;\n  }\n\n}\n\nmodule.exports = Cast;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/util/color.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/util/color.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nclass Color {\n  /**\n   * @typedef {object} RGBObject - An object representing a color in RGB format.\n   * @property {number} r - the red component, in the range [0, 255].\n   * @property {number} g - the green component, in the range [0, 255].\n   * @property {number} b - the blue component, in the range [0, 255].\n   */\n\n  /**\n   * @typedef {object} HSVObject - An object representing a color in HSV format.\n   * @property {number} h - hue, in the range [0-359).\n   * @property {number} s - saturation, in the range [0,1].\n   * @property {number} v - value, in the range [0,1].\n   */\n\n  /** @type {RGBObject} */\n  static get RGB_BLACK() {\n    return {\n      r: 0,\n      g: 0,\n      b: 0\n    };\n  }\n  /** @type {RGBObject} */\n\n\n  static get RGB_WHITE() {\n    return {\n      r: 255,\n      g: 255,\n      b: 255\n    };\n  }\n  /**\n   * Convert a Scratch decimal color to a hex string, #RRGGBB.\n   * @param {number} decimal RGB color as a decimal.\n   * @return {string} RGB color as #RRGGBB hex string.\n   */\n\n\n  static decimalToHex(decimal) {\n    if (decimal < 0) {\n      decimal += 0xFFFFFF + 1;\n    }\n\n    let hex = Number(decimal).toString(16);\n    hex = \"#\".concat('000000'.substr(0, 6 - hex.length)).concat(hex);\n    return hex;\n  }\n  /**\n   * Convert a Scratch decimal color to an RGB color object.\n   * @param {number} decimal RGB color as decimal.\n   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   */\n\n\n  static decimalToRgb(decimal) {\n    const a = decimal >> 24 & 0xFF;\n    const r = decimal >> 16 & 0xFF;\n    const g = decimal >> 8 & 0xFF;\n    const b = decimal & 0xFF;\n    return {\n      r: r,\n      g: g,\n      b: b,\n      a: a > 0 ? a : 255\n    };\n  }\n  /**\n   * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n   * @param {!string} hex Hex representation of the color.\n   * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   */\n\n\n  static hexToRgb(hex) {\n    if (hex.startsWith('#')) {\n      hex = hex.substring(1);\n    }\n\n    const parsed = parseInt(hex, 16);\n\n    if (isNaN(parsed)) {\n      return null;\n    }\n\n    if (hex.length === 6) {\n      return {\n        r: parsed >> 16 & 0xff,\n        g: parsed >> 8 & 0xff,\n        b: parsed & 0xff\n      };\n    } else if (hex.length === 3) {\n      const r = parsed >> 8 & 0xf;\n      const g = parsed >> 4 & 0xf;\n      const b = parsed & 0xf;\n      return {\n        r: r << 4 | r,\n        g: g << 4 | g,\n        b: b << 4 | b\n      };\n    }\n\n    return null;\n  }\n  /**\n   * Convert an RGB color object to a hex color.\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   * @return {!string} Hex representation of the color.\n   */\n\n\n  static rgbToHex(rgb) {\n    return Color.decimalToHex(Color.rgbToDecimal(rgb));\n  }\n  /**\n   * Convert an RGB color object to a Scratch decimal color.\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   * @return {!number} Number representing the color.\n   */\n\n\n  static rgbToDecimal(rgb) {\n    return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n  }\n  /**\n  * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n  * @param {!string} hex Hex representation of the color.\n  * @return {!number} Number representing the color.\n  */\n\n\n  static hexToDecimal(hex) {\n    return Color.rgbToDecimal(Color.hexToRgb(hex));\n  }\n  /**\n   * Convert an HSV color to RGB format.\n   * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   */\n\n\n  static hsvToRgb(hsv) {\n    let h = hsv.h % 360;\n    if (h < 0) h += 360;\n    const s = Math.max(0, Math.min(hsv.s, 1));\n    const v = Math.max(0, Math.min(hsv.v, 1));\n    const i = Math.floor(h / 60);\n    const f = h / 60 - i;\n    const p = v * (1 - s);\n    const q = v * (1 - s * f);\n    const t = v * (1 - s * (1 - f));\n    let r;\n    let g;\n    let b;\n\n    switch (i) {\n      default:\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n\n      case 5:\n        r = v;\n        g = p;\n        b = q;\n        break;\n    }\n\n    return {\n      r: Math.floor(r * 255),\n      g: Math.floor(g * 255),\n      b: Math.floor(b * 255)\n    };\n  }\n  /**\n   * Convert an RGB color to HSV format.\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n   */\n\n\n  static rgbToHsv(rgb) {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const x = Math.min(Math.min(r, g), b);\n    const v = Math.max(Math.max(r, g), b); // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n\n    let h = 0;\n    let s = 0;\n\n    if (x !== v) {\n      const f = r === x ? g - b : g === x ? b - r : r - g;\n      const i = r === x ? 3 : g === x ? 5 : 1;\n      h = (i - f / (v - x)) * 60 % 360;\n      s = (v - x) / v;\n    }\n\n    return {\n      h: h,\n      s: s,\n      v: v\n    };\n  }\n  /**\n   * Linear interpolation between rgb0 and rgb1.\n   * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n   * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n   * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n   * @return {RGBObject} the interpolated color.\n   */\n\n\n  static mixRgb(rgb0, rgb1, fraction1) {\n    if (fraction1 <= 0) return rgb0;\n    if (fraction1 >= 1) return rgb1;\n    const fraction0 = 1 - fraction1;\n    return {\n      r: fraction0 * rgb0.r + fraction1 * rgb1.r,\n      g: fraction0 * rgb0.g + fraction1 * rgb1.g,\n      b: fraction0 * rgb0.b + fraction1 * rgb1.b\n    };\n  }\n\n}\n\nmodule.exports = Color;\n\n/***/ }),\n\n/***/ \"./node_modules/scratch-vm/src/util/log.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/scratch-vm/src/util/log.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst minilog = __webpack_require__(/*! minilog */ \"./node_modules/minilog/lib/web/index.js\");\n\nminilog.enable();\nmodule.exports = minilog('vm');\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=extension worker.js.map";

/***/ })

}]);
//# sourceMappingURL=iframe-extension-worker.js.map