{"version":3,"file":"js/iframe-extension-worker.js","sources":["webpack://GUI/./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker.js","webpack://GUI/./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js"],"sourcesContent":["const uid = require('../util/uid');\nconst frameSource = require('./tw-load-script-as-plain-text!./tw-iframe-extension-worker-entry');\n\nconst none = \"'none'\";\nconst featurePolicy = {\n    'accelerometer': none,\n    'ambient-light-sensor': none,\n    'battery': none,\n    'camera': none,\n    'display-capture': none,\n    'document-domain': none,\n    'encrypted-media': none,\n    'fullscreen': none,\n    'geolocation': none,\n    'gyroscope': none,\n    'magnetometer': none,\n    'microphone': none,\n    'midi': none,\n    'payment': none,\n    'picture-in-picture': none,\n    'publickey-credentials-get': none,\n    'speaker-selection': none,\n    'usb': none,\n    'vibrate': none,\n    'vr': none,\n    'screen-wake-lock': none,\n    'web-share': none,\n    'interest-cohort': none\n};\n\nconst generateAllow = () => Object.entries(featurePolicy)\n    .map(([name, permission]) => `${name} ${permission}`)\n    .join('; ');\n\nclass IframeExtensionWorker {\n    constructor () {\n        this.id = uid();\n        this.isRemote = true;\n        this.ready = false;\n        this.queuedMessages = [];\n\n        this.iframe = document.createElement('iframe');\n        this.iframe.className = 'tw-custom-extension-frame';\n        this.iframe.dataset.id = this.id;\n        this.iframe.style.display = 'none';\n        this.iframe.setAttribute('aria-hidden', 'true');\n        this.iframe.sandbox = 'allow-scripts';\n        this.iframe.allow = generateAllow();\n        document.body.appendChild(this.iframe);\n\n        window.addEventListener('message', this._onWindowMessage.bind(this));\n        const blob = new Blob([\n            // eslint-disable-next-line max-len\n            `<!DOCTYPE html><body><script>window.__WRAPPED_IFRAME_ID__=${JSON.stringify(this.id)};${frameSource}</script></body>`\n        ], {\n            type: 'text/html; charset=utf-8'\n        });\n        this.iframe.src = URL.createObjectURL(blob);\n    }\n\n    _onWindowMessage (e) {\n        if (!e.data || e.data.vmIframeId !== this.id) {\n            return;\n        }\n        if (e.data.ready) {\n            this.ready = true;\n            for (const {data, transfer} of this.queuedMessages) {\n                this.postMessage(data, transfer);\n            }\n            this.queuedMessages.length = 0;\n        }\n        if (e.data.message) {\n            this.onmessage({\n                data: e.data.message\n            });\n        }\n    }\n\n    onmessage () {\n        // Should be overridden\n    }\n\n    postMessage (data, transfer) {\n        if (this.ready) {\n            if (transfer) {\n                this.iframe.contentWindow.postMessage(data, '*', transfer);\n            } else {\n                this.iframe.contentWindow.postMessage(data, '*');\n            }\n        } else {\n            this.queuedMessages.push({data, transfer});\n        }\n    }\n}\n\nmodule.exports = IframeExtensionWorker;\n","module.exports = \"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./node_modules/babel-loader/lib/index.js?!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./node_modules/babel-loader/lib/index.js?!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js\\\":\\n/*!***********************************************************************************************************************************!*\\\\\\n  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/scratch-vm/src/extension-support/tw-iframe-extension-worker-entry.js ***!\\n  \\\\***********************************************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(global) {const context = __webpack_require__(/*! ./tw-extension-worker-context */ \\\"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\\\");\\nconst jQuery = __webpack_require__(/*! ./tw-jquery-shim */ \\\"./node_modules/scratch-vm/src/extension-support/tw-jquery-shim.js\\\");\\nglobal.$ = jQuery;\\nglobal.jQuery = jQuery;\\nconst id = window.__WRAPPED_IFRAME_ID__;\\ncontext.isWorker = false;\\ncontext.centralDispatchService = {\\n  postMessage(message, transfer) {\\n    const data = {\\n      vmIframeId: id,\\n      message\\n    };\\n    if (transfer) {\\n      window.parent.postMessage(data, '*', transfer);\\n    } else {\\n      window.parent.postMessage(data, '*');\\n    }\\n  }\\n};\\n__webpack_require__(/*! ./extension-worker */ \\\"./node_modules/scratch-vm/src/extension-support/extension-worker.js\\\");\\nwindow.parent.postMessage({\\n  vmIframeId: id,\\n  ready: true\\n}, '*');\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \\\"./node_modules/webpack/buildin/global.js\\\")))\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/index.js\\\":\\n/*!********************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message-interpret/index.js ***!\\n  \\\\********************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n// @flow\\n\\nvar formats = __webpack_require__(/*! format-message-formats */ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/node_modules/format-message-formats/index.js\\\")\\nvar lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/node_modules/lookup-closest-locale/index.js\\\")\\nvar plurals = __webpack_require__(/*! ./plurals */ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/plurals.js\\\")\\n\\n/*::\\nimport type {\\n  AST,\\n  SubMessages\\n} from '../format-message-parse'\\ntype Locale = string\\ntype Locales = Locale | Locale[]\\ntype Placeholder = any[] // https://github.com/facebook/flow/issues/4050\\nexport type Type = (Placeholder, Locales) => (any, ?Object) => any\\nexport type Types = { [string]: Type }\\n*/\\n\\nexports = module.exports = function interpret (\\n  ast/*: AST */,\\n  locale/*:: ?: Locales */,\\n  types/*:: ?: Types */\\n)/*: (args?: Object) => string */ {\\n  return interpretAST(ast, null, locale || 'en', types || {}, true)\\n}\\n\\nexports.toParts = function toParts (\\n  ast/*: AST */,\\n  locale/*:: ?: Locales */,\\n  types/*:: ?: Types */\\n)/*: (args?: Object) => any[] */ {\\n  return interpretAST(ast, null, locale || 'en', types || {}, false)\\n}\\n\\nfunction interpretAST (\\n  elements/*: any[] */,\\n  parent/*: ?Placeholder */,\\n  locale/*: Locales */,\\n  types/*: Types */,\\n  join/*: boolean */\\n)/*: Function */ {\\n  var parts = elements.map(function (element) {\\n    return interpretElement(element, parent, locale, types, join)\\n  })\\n\\n  if (!join) {\\n    return function format (args) {\\n      return parts.reduce(function (parts, part) {\\n        return parts.concat(part(args))\\n      }, [])\\n    }\\n  }\\n\\n  if (parts.length === 1) return parts[0]\\n  return function format (args) {\\n    var message = ''\\n    for (var e = 0; e < parts.length; ++e) {\\n      message += parts[e](args)\\n    }\\n    return message\\n  }\\n}\\n\\nfunction interpretElement (\\n  element/*: Placeholder */,\\n  parent/*: ?Placeholder */,\\n  locale/*: Locales */,\\n  types/*: Types */,\\n  join/*: boolean */\\n)/*: Function */ {\\n  if (typeof element === 'string') {\\n    var value/*: string */ = element\\n    return function format () { return value }\\n  }\\n\\n  var id = element[0]\\n  var type = element[1]\\n\\n  if (parent && element[0] === '#') {\\n    id = parent[0]\\n    var offset = parent[2]\\n    var formatter = (types.number || defaults.number)([ id, 'number' ], locale)\\n    return function format (args) {\\n      return formatter(getArg(id, args) - offset, args)\\n    }\\n  }\\n\\n  // pre-process children\\n  var children\\n  if (type === 'plural' || type === 'selectordinal') {\\n    children = {}\\n    Object.keys(element[3]).forEach(function (key) {\\n      children[key] = interpretAST(element[3][key], element, locale, types, join)\\n    })\\n    element = [ element[0], element[1], element[2], children ]\\n  } else if (element[2] && typeof element[2] === 'object') {\\n    children = {}\\n    Object.keys(element[2]).forEach(function (key) {\\n      children[key] = interpretAST(element[2][key], element, locale, types, join)\\n    })\\n    element = [ element[0], element[1], children ]\\n  }\\n\\n  var getFrmt = type && (types[type] || defaults[type])\\n  if (getFrmt) {\\n    var frmt = getFrmt(element, locale)\\n    return function format (args) {\\n      return frmt(getArg(id, args), args)\\n    }\\n  }\\n\\n  return join\\n    ? function format (args) { return String(getArg(id, args)) }\\n    : function format (args) { return getArg(id, args) }\\n}\\n\\nfunction getArg (id/*: string */, args/*: ?Object */)/*: any */ {\\n  if (args && (id in args)) return args[id]\\n  var parts = id.split('.')\\n  var a = args\\n  for (var i = 0, ii = parts.length; a && i < ii; ++i) {\\n    a = a[parts[i]]\\n  }\\n  return a\\n}\\n\\nfunction interpretNumber (element/*: Placeholder */, locales/*: Locales */) {\\n  var style = element[2]\\n  var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default\\n  return new Intl.NumberFormat(locales, options).format\\n}\\n\\nfunction interpretDuration (element/*: Placeholder */, locales/*: Locales */) {\\n  var style = element[2]\\n  var options = formats.duration[style] || formats.duration.default\\n  var fs = new Intl.NumberFormat(locales, options.seconds).format\\n  var fm = new Intl.NumberFormat(locales, options.minutes).format\\n  var fh = new Intl.NumberFormat(locales, options.hours).format\\n  var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':'\\n\\n  return function (s, args) {\\n    s = +s\\n    if (!isFinite(s)) return fs(s)\\n    var h = ~~(s / 60 / 60) // ~~ acts much like Math.trunc\\n    var m = ~~(s / 60 % 60)\\n    var dur = (h ? (fh(Math.abs(h)) + sep) : '') +\\n      fm(Math.abs(m)) + sep + fs(Math.abs(s % 60))\\n    return s < 0 ? fh(-1).replace(fh(1), dur) : dur\\n  }\\n}\\n\\nfunction interpretDateTime (element/*: Placeholder */, locales/*: Locales */) {\\n  var type = element[1]\\n  var style = element[2]\\n  var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default\\n  return new Intl.DateTimeFormat(locales, options).format\\n}\\n\\nfunction interpretPlural (element/*: Placeholder */, locales/*: Locales */) {\\n  var type = element[1]\\n  var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal'\\n  var offset = element[2]\\n  var children = element[3]\\n  var pluralRules\\n  if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {\\n    pluralRules = new Intl.PluralRules(locales, { type: pluralType })\\n  } else {\\n    var locale = lookupClosestLocale(locales, plurals)\\n    var select = (locale && plurals[locale][pluralType]) || returnOther\\n    pluralRules = { select: select }\\n  }\\n\\n  return function (value, args) {\\n    var clause =\\n      children['=' + +value] ||\\n      children[pluralRules.select(value - offset)] ||\\n      children.other\\n    return clause(args)\\n  }\\n}\\n\\nfunction returnOther (/*:: n:number */) { return 'other' }\\n\\nfunction interpretSelect (element/*: Placeholder */, locales/*: Locales */) {\\n  var children = element[2]\\n  return function (value, args) {\\n    var clause = children[value] || children.other\\n    return clause(args)\\n  }\\n}\\n\\nvar defaults/*: Types */ = {\\n  number: interpretNumber,\\n  ordinal: interpretNumber, // TODO: support rbnf\\n  spellout: interpretNumber, // TODO: support rbnf\\n  duration: interpretDuration,\\n  date: interpretDateTime,\\n  time: interpretDateTime,\\n  plural: interpretPlural,\\n  selectordinal: interpretPlural,\\n  select: interpretSelect\\n}\\nexports.types = defaults\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/node_modules/format-message-formats/index.js\\\":\\n/*!********************************************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message-interpret/node_modules/format-message-formats/index.js ***!\\n  \\\\********************************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n// @flow\\nvar LONG = 'long'\\nvar SHORT = 'short'\\nvar NARROW = 'narrow'\\nvar NUMERIC = 'numeric'\\nvar TWODIGIT = '2-digit'\\n\\n/**\\n * formatting information\\n **/\\nmodule.exports = {\\n  number: {\\n    decimal: {\\n      style: 'decimal'\\n    },\\n    integer: {\\n      style: 'decimal',\\n      maximumFractionDigits: 0\\n    },\\n    currency: {\\n      style: 'currency',\\n      currency: 'USD'\\n    },\\n    percent: {\\n      style: 'percent'\\n    },\\n    default: {\\n      style: 'decimal'\\n    }\\n  },\\n  date: {\\n    short: {\\n      month: NUMERIC,\\n      day: NUMERIC,\\n      year: TWODIGIT\\n    },\\n    medium: {\\n      month: SHORT,\\n      day: NUMERIC,\\n      year: NUMERIC\\n    },\\n    long: {\\n      month: LONG,\\n      day: NUMERIC,\\n      year: NUMERIC\\n    },\\n    full: {\\n      month: LONG,\\n      day: NUMERIC,\\n      year: NUMERIC,\\n      weekday: LONG\\n    },\\n    default: {\\n      month: SHORT,\\n      day: NUMERIC,\\n      year: NUMERIC\\n    }\\n  },\\n  time: {\\n    short: {\\n      hour: NUMERIC,\\n      minute: NUMERIC\\n    },\\n    medium: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC\\n    },\\n    long: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC,\\n      timeZoneName: SHORT\\n    },\\n    full: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC,\\n      timeZoneName: SHORT\\n    },\\n    default: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC\\n    }\\n  },\\n  duration: {\\n    default: {\\n      hours: {\\n        minimumIntegerDigits: 1,\\n        maximumFractionDigits: 0\\n      },\\n      minutes: {\\n        minimumIntegerDigits: 2,\\n        maximumFractionDigits: 0\\n      },\\n      seconds: {\\n        minimumIntegerDigits: 2,\\n        maximumFractionDigits: 3\\n      }\\n    }\\n  },\\n  parseNumberPattern: function (pattern/*: ?string */) {\\n    if (!pattern) return\\n    var options = {}\\n    var currency = pattern.match(/\\\\b[A-Z]{3}\\\\b/i)\\n    var syms = pattern.replace(/[^¤]/g, '').length\\n    if (!syms && currency) syms = 1\\n    if (syms) {\\n      options.style = 'currency'\\n      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name'\\n      options.currency = currency ? currency[0].toUpperCase() : 'USD'\\n    } else if (pattern.indexOf('%') >= 0) {\\n      options.style = 'percent'\\n    }\\n    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined\\n    options.useGrouping = pattern.indexOf(',') >= 0\\n    if (/E\\\\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {\\n      var size = pattern.replace(/E\\\\+?[@#0]+|[^@#0]/gi, '')\\n      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21)\\n      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21)\\n    } else {\\n      var parts = pattern.replace(/[^#0.]/g, '').split('.')\\n      var integer = parts[0]\\n      var n = integer.length - 1\\n      while (integer[n] === '0') --n\\n      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21)\\n      var fraction = parts[1] || ''\\n      n = 0\\n      while (fraction[n] === '0') ++n\\n      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20)\\n      while (fraction[n] === '#') ++n\\n      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20)\\n    }\\n    return options\\n  },\\n  parseDatePattern: function (pattern/*: ?string */) {\\n    if (!pattern) return\\n    var options = {}\\n    for (var i = 0; i < pattern.length;) {\\n      var current = pattern[i]\\n      var n = 1\\n      while (pattern[++i] === current) ++n\\n      switch (current) {\\n        case 'G':\\n          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT\\n          break\\n        case 'y':\\n        case 'Y':\\n          options.year = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'M':\\n        case 'L':\\n          n = Math.min(Math.max(n - 1, 0), 4)\\n          options.month = [ NUMERIC, TWODIGIT, SHORT, LONG, NARROW ][n]\\n          break\\n        case 'E':\\n        case 'e':\\n        case 'c':\\n          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT\\n          break\\n        case 'd':\\n        case 'D':\\n          options.day = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'h':\\n        case 'K':\\n          options.hour12 = true\\n          options.hour = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'H':\\n        case 'k':\\n          options.hour12 = false\\n          options.hour = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'm':\\n          options.minute = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 's':\\n        case 'S':\\n          options.second = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'z':\\n        case 'Z':\\n        case 'v':\\n        case 'V':\\n          options.timeZoneName = n === 1 ? SHORT : LONG\\n          break\\n      }\\n    }\\n    return Object.keys(options).length ? options : undefined\\n  }\\n}\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/node_modules/lookup-closest-locale/index.js\\\":\\n/*!*******************************************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message-interpret/node_modules/lookup-closest-locale/index.js ***!\\n  \\\\*******************************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n// @flow\\n// \\\"lookup\\\" algorithm http://tools.ietf.org/html/rfc4647#section-3.4\\n// assumes normalized language tags, and matches in a case sensitive manner\\nmodule.exports = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {\\n  if (typeof locale === 'string' && available[locale]) return locale\\n  var locales = [].concat(locale || [])\\n  for (var l = 0, ll = locales.length; l < ll; ++l) {\\n    var current = locales[l].split('-')\\n    while (current.length) {\\n      var candidate = current.join('-')\\n      if (available[candidate]) return candidate\\n      current.pop()\\n    }\\n  }\\n}\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/plurals.js\\\":\\n/*!**********************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message-interpret/plurals.js ***!\\n  \\\\**********************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n// @flow\\n\\n\\n/*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */\\nvar zero = 'zero', one = 'one', two = 'two', few = 'few', many = 'many', other = 'other'\\nvar f = [\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return 0 <= n && n <= 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var n = +s\\n    return i === 0 || n === 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 0 ? zero\\n      : n === 1 ? one\\n      : n === 2 ? two\\n      : 3 <= n % 100 && n % 100 <= 10 ? few\\n      : 11 <= n % 100 && n % 100 <= 99 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    return i === 1 && v === 0 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n % 10 === 1 && n % 100 !== 11 ? one\\n      : (2 <= n % 10 && n % 10 <= 4) && (n % 100 < 12 || 14 < n % 100) ? few\\n      : n % 10 === 0 || (5 <= n % 10 && n % 10 <= 9) || (11 <= n % 100 && n % 100 <= 14) ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n % 10 === 1 && (n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91) ? one\\n      : n % 10 === 2 && (n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92) ? two\\n      : ((3 <= n % 10 && n % 10 <= 4) || n % 10 === 9) && ((n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100)) ? few\\n      : n !== 0 && n % 1000000 === 0 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    var f = +(s + '.').split('.')[1]\\n    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one\\n      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) || (2 <= f % 10 && f % 10 <= 4) && (f % 100 < 12 || 14 < f % 100) ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    return i === 1 && v === 0 ? one\\n      : (2 <= i && i <= 4) && v === 0 ? few\\n      : v !== 0 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 0 ? zero\\n      : n === 1 ? one\\n      : n === 2 ? two\\n      : n === 3 ? few\\n      : n === 6 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')\\n    var n = +s\\n    return n === 1 || t !== 0 && (i === 0 || i === 1) ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    var f = +(s + '.').split('.')[1]\\n    return v === 0 && i % 100 === 1 || f % 100 === 1 ? one\\n      : v === 0 && i % 100 === 2 || f % 100 === 2 ? two\\n      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || (3 <= f % 100 && f % 100 <= 4) ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    return i === 0 || i === 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    var f = +(s + '.').split('.')[1]\\n    return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && (i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9) || v !== 0 && (f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9) ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : n === 2 ? two\\n      : 3 <= n && n <= 6 ? few\\n      : 7 <= n && n <= 10 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 || n === 11 ? one\\n      : n === 2 || n === 12 ? two\\n      : ((3 <= n && n <= 10) || (13 <= n && n <= 19)) ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    return v === 0 && i % 10 === 1 ? one\\n      : v === 0 && i % 10 === 2 ? two\\n      : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few\\n      : v !== 0 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    var n = +s\\n    return i === 1 && v === 0 ? one\\n      : i === 2 && v === 0 ? two\\n      : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')\\n    return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : n === 2 ? two\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 0 ? zero\\n      : n === 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var n = +s\\n    return n === 0 ? zero\\n      : (i === 0 || i === 1) && n !== 0 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var f = +(s + '.').split('.')[1]\\n    var n = +s\\n    return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one\\n      : (2 <= n % 10 && n % 10 <= 9) && (n % 100 < 11 || 19 < n % 100) ? few\\n      : f !== 0 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var v = (s + '.').split('.')[1].length\\n    var f = +(s + '.').split('.')[1]\\n    var n = +s\\n    return n % 10 === 0 || (11 <= n % 100 && n % 100 <= 19) || v === 2 && (11 <= f % 100 && f % 100 <= 19) ? zero\\n      : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    var f = +(s + '.').split('.')[1]\\n    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    var n = +s\\n    return i === 1 && v === 0 ? one\\n      : v !== 0 || n === 0 || n !== 1 && (1 <= n % 100 && n % 100 <= 19) ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : n === 0 || (2 <= n % 100 && n % 100 <= 10) ? few\\n      : 11 <= n % 100 && n % 100 <= 19 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    return i === 1 && v === 0 ? one\\n      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few\\n      : v === 0 && i !== 1 && (0 <= i % 10 && i % 10 <= 1) || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (12 <= i % 100 && i % 100 <= 14) ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    return 0 <= i && i <= 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one\\n      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few\\n      : v === 0 && i % 10 === 0 || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (11 <= i % 100 && i % 100 <= 14) ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var n = +s\\n    return i === 0 || n === 1 ? one\\n      : 2 <= n && n <= 10 ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var f = +(s + '.').split('.')[1]\\n    var n = +s\\n    return (n === 0 || n === 1) || i === 0 && f === 1 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    var v = (s + '.').split('.')[1].length\\n    return v === 0 && i % 100 === 1 ? one\\n      : v === 0 && i % 100 === 2 ? two\\n      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || v !== 0 ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return (0 <= n && n <= 1) || (11 <= n && n <= 99) ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one\\n      : n === 2 || n === 3 ? two\\n      : n === 4 ? few\\n      : n === 6 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    return (i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8) || (i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80) ? one\\n      : (i % 10 === 3 || i % 10 === 4) || (i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900) ? few\\n      : i === 0 || i % 10 === 6 || (i % 100 === 40 || i % 100 === 60 || i % 100 === 90) ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return (n % 10 === 2 || n % 10 === 3) && (n % 100 !== 12 && n % 100 !== 13) ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 || n === 3 ? one\\n      : n === 2 ? two\\n      : n === 4 ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 0 || n === 7 || n === 8 || n === 9 ? zero\\n      : n === 1 ? one\\n      : n === 2 ? two\\n      : n === 3 || n === 4 ? few\\n      : n === 5 || n === 6 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n % 10 === 1 && n % 100 !== 11 ? one\\n      : n % 10 === 2 && n % 100 !== 12 ? two\\n      : n % 10 === 3 && n % 100 !== 13 ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : n === 2 || n === 3 ? two\\n      : n === 4 ? few\\n      : n === 6 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 || n === 5 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 11 || n === 8 || n === 80 || n === 800 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    return i === 1 ? one\\n      : i === 0 || ((2 <= i % 100 && i % 100 <= 20) || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var i = Math.floor(Math.abs(+s))\\n    return i % 10 === 1 && i % 100 !== 11 ? one\\n      : i % 10 === 2 && i % 100 !== 12 ? two\\n      : (i % 10 === 7 || i % 10 === 8) && (i % 100 !== 17 && i % 100 !== 18) ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : n === 2 || n === 3 ? two\\n      : n === 4 ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return 1 <= n && n <= 4 ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return (n === 1 || n === 5 || (7 <= n && n <= 9)) ? one\\n      : n === 2 || n === 3 ? two\\n      : n === 4 ? few\\n      : n === 6 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n === 1 ? one\\n      : n % 10 === 4 && n % 100 !== 14 ? many\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return (n % 10 === 1 || n % 10 === 2) && (n % 100 !== 11 && n % 100 !== 12) ? one\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return (n % 10 === 6 || n % 10 === 9) || n === 10 ? few\\n      : other\\n  },\\n  function (s/*: string | number */)/*: Rule */ {\\n    var n = +s\\n    return n % 10 === 3 && n % 100 !== 13 ? few\\n      : other\\n  }\\n]\\n\\nmodule.exports = {\\n  af: { cardinal: f[0] },\\n  ak: { cardinal: f[1] },\\n  am: { cardinal: f[2] },\\n  ar: { cardinal: f[3] },\\n  ars: { cardinal: f[3] },\\n  as: { cardinal: f[2], ordinal: f[34] },\\n  asa: { cardinal: f[0] },\\n  ast: { cardinal: f[4] },\\n  az: { cardinal: f[0], ordinal: f[35] },\\n  be: { cardinal: f[5], ordinal: f[36] },\\n  bem: { cardinal: f[0] },\\n  bez: { cardinal: f[0] },\\n  bg: { cardinal: f[0] },\\n  bh: { cardinal: f[1] },\\n  bn: { cardinal: f[2], ordinal: f[34] },\\n  br: { cardinal: f[6] },\\n  brx: { cardinal: f[0] },\\n  bs: { cardinal: f[7] },\\n  ca: { cardinal: f[4], ordinal: f[37] },\\n  ce: { cardinal: f[0] },\\n  cgg: { cardinal: f[0] },\\n  chr: { cardinal: f[0] },\\n  ckb: { cardinal: f[0] },\\n  cs: { cardinal: f[8] },\\n  cy: { cardinal: f[9], ordinal: f[38] },\\n  da: { cardinal: f[10] },\\n  de: { cardinal: f[4] },\\n  dsb: { cardinal: f[11] },\\n  dv: { cardinal: f[0] },\\n  ee: { cardinal: f[0] },\\n  el: { cardinal: f[0] },\\n  en: { cardinal: f[4], ordinal: f[39] },\\n  eo: { cardinal: f[0] },\\n  es: { cardinal: f[0] },\\n  et: { cardinal: f[4] },\\n  eu: { cardinal: f[0] },\\n  fa: { cardinal: f[2] },\\n  ff: { cardinal: f[12] },\\n  fi: { cardinal: f[4] },\\n  fil: { cardinal: f[13], ordinal: f[0] },\\n  fo: { cardinal: f[0] },\\n  fr: { cardinal: f[12], ordinal: f[0] },\\n  fur: { cardinal: f[0] },\\n  fy: { cardinal: f[4] },\\n  ga: { cardinal: f[14], ordinal: f[0] },\\n  gd: { cardinal: f[15] },\\n  gl: { cardinal: f[4] },\\n  gsw: { cardinal: f[0] },\\n  gu: { cardinal: f[2], ordinal: f[40] },\\n  guw: { cardinal: f[1] },\\n  gv: { cardinal: f[16] },\\n  ha: { cardinal: f[0] },\\n  haw: { cardinal: f[0] },\\n  he: { cardinal: f[17] },\\n  hi: { cardinal: f[2], ordinal: f[40] },\\n  hr: { cardinal: f[7] },\\n  hsb: { cardinal: f[11] },\\n  hu: { cardinal: f[0], ordinal: f[41] },\\n  hy: { cardinal: f[12], ordinal: f[0] },\\n  io: { cardinal: f[4] },\\n  is: { cardinal: f[18] },\\n  it: { cardinal: f[4], ordinal: f[42] },\\n  iu: { cardinal: f[19] },\\n  iw: { cardinal: f[17] },\\n  jgo: { cardinal: f[0] },\\n  ji: { cardinal: f[4] },\\n  jmc: { cardinal: f[0] },\\n  ka: { cardinal: f[0], ordinal: f[43] },\\n  kab: { cardinal: f[12] },\\n  kaj: { cardinal: f[0] },\\n  kcg: { cardinal: f[0] },\\n  kk: { cardinal: f[0], ordinal: f[44] },\\n  kkj: { cardinal: f[0] },\\n  kl: { cardinal: f[0] },\\n  kn: { cardinal: f[2] },\\n  ks: { cardinal: f[0] },\\n  ksb: { cardinal: f[0] },\\n  ksh: { cardinal: f[20] },\\n  ku: { cardinal: f[0] },\\n  kw: { cardinal: f[19] },\\n  ky: { cardinal: f[0] },\\n  lag: { cardinal: f[21] },\\n  lb: { cardinal: f[0] },\\n  lg: { cardinal: f[0] },\\n  ln: { cardinal: f[1] },\\n  lt: { cardinal: f[22] },\\n  lv: { cardinal: f[23] },\\n  mas: { cardinal: f[0] },\\n  mg: { cardinal: f[1] },\\n  mgo: { cardinal: f[0] },\\n  mk: { cardinal: f[24], ordinal: f[45] },\\n  ml: { cardinal: f[0] },\\n  mn: { cardinal: f[0] },\\n  mo: { cardinal: f[25], ordinal: f[0] },\\n  mr: { cardinal: f[2], ordinal: f[46] },\\n  mt: { cardinal: f[26] },\\n  nah: { cardinal: f[0] },\\n  naq: { cardinal: f[19] },\\n  nb: { cardinal: f[0] },\\n  nd: { cardinal: f[0] },\\n  ne: { cardinal: f[0], ordinal: f[47] },\\n  nl: { cardinal: f[4] },\\n  nn: { cardinal: f[0] },\\n  nnh: { cardinal: f[0] },\\n  no: { cardinal: f[0] },\\n  nr: { cardinal: f[0] },\\n  nso: { cardinal: f[1] },\\n  ny: { cardinal: f[0] },\\n  nyn: { cardinal: f[0] },\\n  om: { cardinal: f[0] },\\n  or: { cardinal: f[0], ordinal: f[48] },\\n  os: { cardinal: f[0] },\\n  pa: { cardinal: f[1] },\\n  pap: { cardinal: f[0] },\\n  pl: { cardinal: f[27] },\\n  prg: { cardinal: f[23] },\\n  ps: { cardinal: f[0] },\\n  pt: { cardinal: f[28] },\\n  'pt-PT': { cardinal: f[4] },\\n  rm: { cardinal: f[0] },\\n  ro: { cardinal: f[25], ordinal: f[0] },\\n  rof: { cardinal: f[0] },\\n  ru: { cardinal: f[29] },\\n  rwk: { cardinal: f[0] },\\n  saq: { cardinal: f[0] },\\n  scn: { cardinal: f[4], ordinal: f[42] },\\n  sd: { cardinal: f[0] },\\n  sdh: { cardinal: f[0] },\\n  se: { cardinal: f[19] },\\n  seh: { cardinal: f[0] },\\n  sh: { cardinal: f[7] },\\n  shi: { cardinal: f[30] },\\n  si: { cardinal: f[31] },\\n  sk: { cardinal: f[8] },\\n  sl: { cardinal: f[32] },\\n  sma: { cardinal: f[19] },\\n  smi: { cardinal: f[19] },\\n  smj: { cardinal: f[19] },\\n  smn: { cardinal: f[19] },\\n  sms: { cardinal: f[19] },\\n  sn: { cardinal: f[0] },\\n  so: { cardinal: f[0] },\\n  sq: { cardinal: f[0], ordinal: f[49] },\\n  sr: { cardinal: f[7] },\\n  ss: { cardinal: f[0] },\\n  ssy: { cardinal: f[0] },\\n  st: { cardinal: f[0] },\\n  sv: { cardinal: f[4], ordinal: f[50] },\\n  sw: { cardinal: f[4] },\\n  syr: { cardinal: f[0] },\\n  ta: { cardinal: f[0] },\\n  te: { cardinal: f[0] },\\n  teo: { cardinal: f[0] },\\n  ti: { cardinal: f[1] },\\n  tig: { cardinal: f[0] },\\n  tk: { cardinal: f[0], ordinal: f[51] },\\n  tl: { cardinal: f[13], ordinal: f[0] },\\n  tn: { cardinal: f[0] },\\n  tr: { cardinal: f[0] },\\n  ts: { cardinal: f[0] },\\n  tzm: { cardinal: f[33] },\\n  ug: { cardinal: f[0] },\\n  uk: { cardinal: f[29], ordinal: f[52] },\\n  ur: { cardinal: f[4] },\\n  uz: { cardinal: f[0] },\\n  ve: { cardinal: f[0] },\\n  vo: { cardinal: f[0] },\\n  vun: { cardinal: f[0] },\\n  wa: { cardinal: f[1] },\\n  wae: { cardinal: f[0] },\\n  xh: { cardinal: f[0] },\\n  xog: { cardinal: f[0] },\\n  yi: { cardinal: f[4] },\\n  zu: { cardinal: f[2] },\\n  lo: { ordinal: f[0] },\\n  ms: { ordinal: f[0] },\\n  vi: { ordinal: f[0] }\\n}\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message/index.js\\\":\\n/*!**********************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message/index.js ***!\\n  \\\\**********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n// @flow\\n\\nvar parse = __webpack_require__(/*! format-message-parse */ \\\"./node_modules/scratch-vm/node_modules/format-message/node_modules/format-message-parse/index.js\\\")\\nvar interpret = __webpack_require__(/*! format-message-interpret */ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/index.js\\\")\\nvar plurals = __webpack_require__(/*! format-message-interpret/plurals */ \\\"./node_modules/scratch-vm/node_modules/format-message-interpret/plurals.js\\\")\\nvar lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ \\\"./node_modules/scratch-vm/node_modules/format-message/node_modules/lookup-closest-locale/index.js\\\")\\nvar origFormats = __webpack_require__(/*! format-message-formats */ \\\"./node_modules/scratch-vm/node_modules/format-message/node_modules/format-message-formats/index.js\\\")\\n\\n/*::\\nimport type { Types } from 'format-message-interpret'\\ntype Locale = string\\ntype Locales = Locale | Locale[]\\ntype Message = string | {|\\n  id?: string,\\n  default: string,\\n  description?: string\\n|}\\ntype Translations = { [string]: ?{ [string]: string | Translation } }\\ntype Translation = {\\n  message: string,\\n  format?: (args?: Object) => string,\\n  toParts?: (args?: Object) => any[],\\n}\\ntype Replacement = ?string | (string, string, locales?: Locales) => ?string\\ntype GenerateId = (string) => string\\ntype MissingTranslation = 'ignore' | 'warning' | 'error'\\ntype FormatObject = { [string]: * }\\ntype Options = {\\n  locale?: Locales,\\n  translations?: ?Translations,\\n  generateId?: GenerateId,\\n  missingReplacement?: Replacement,\\n  missingTranslation?: MissingTranslation,\\n  formats?: {\\n    number?: FormatObject,\\n    date?: FormatObject,\\n    time?: FormatObject\\n  },\\n  types?: Types\\n}\\ntype Setup = {|\\n  locale: Locales,\\n  translations: Translations,\\n  generateId: GenerateId,\\n  missingReplacement: Replacement,\\n  missingTranslation: MissingTranslation,\\n  formats: {\\n    number: FormatObject,\\n    date: FormatObject,\\n    time: FormatObject\\n  },\\n  types: Types\\n|}\\ntype FormatMessage = {\\n  (msg: Message, args?: Object, locales?: Locales): string,\\n  rich (msg: Message, args?: Object, locales?: Locales): any[],\\n  setup (opt?: Options): Setup,\\n  number (value: number, style?: string, locales?: Locales): string,\\n  date (value: number | Date, style?: string, locales?: Locales): string,\\n  time (value: number | Date, style?: string, locales?: Locales): string,\\n  select (value: any, options: Object): any,\\n  custom (placeholder: any[], locales: Locales, value: any, args: Object): any,\\n  plural (value: number, offset: any, options: any, locale: any): any,\\n  selectordinal (value: number, offset: any, options: any, locale: any): any,\\n  namespace (): FormatMessage\\n}\\n*/\\n\\nfunction assign/*:: <T: Object> */ (target/*: T */, source/*: Object */) {\\n  Object.keys(source).forEach(function (key) { target[key] = source[key] })\\n  return target\\n}\\n\\nfunction namespace ()/*: FormatMessage */ {\\n  var formats = assign({}, origFormats)\\n  var currentLocales/*: Locales */ = 'en'\\n  var translations/*: Translations */ = {}\\n  var generateId/*: GenerateId */ = function (pattern) { return pattern }\\n  var missingReplacement/*: Replacement */ = null\\n  var missingTranslation/*: MissingTranslation */ = 'warning'\\n  var types/*: Types */ = {}\\n\\n  function formatMessage (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {\\n    var pattern = typeof msg === 'string' ? msg : msg.default\\n    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)\\n    var translated = translate(pattern, id, locales || currentLocales)\\n    var format = translated.format || (\\n      translated.format = interpret(parse(translated.message), locales || currentLocales, types)\\n    )\\n    return format(args)\\n  }\\n\\n  formatMessage.rich = function rich (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {\\n    var pattern = typeof msg === 'string' ? msg : msg.default\\n    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)\\n    var translated = translate(pattern, id, locales || currentLocales)\\n    var format = translated.toParts || (\\n      translated.toParts = interpret.toParts(parse(translated.message, { tagsType: tagsType }), locales || currentLocales, types)\\n    )\\n    return format(args)\\n  }\\n\\n  var tagsType = '<>'\\n  function richType (node/*: any[] */, locales/*: Locales */) {\\n    var style = node[2]\\n    return function (fn, args) {\\n      var props = typeof style === 'object' ? mapObject(style, args) : style\\n      return typeof fn === 'function' ? fn(props) : fn\\n    }\\n  }\\n  types[tagsType] = richType\\n\\n  function mapObject (object/* { [string]: (args?: Object) => any } */, args/*: ?Object */) {\\n    return Object.keys(object).reduce(function (mapped, key) {\\n      mapped[key] = object[key](args)\\n      return mapped\\n    }, {})\\n  }\\n\\n  function translate (pattern/*: string */, id/*: string */, locales/*: Locales */)/*: Translation */ {\\n    var locale = lookupClosestLocale(locales, translations) || 'en'\\n    var messages = translations[locale] || (translations[locale] = {})\\n    var translated = messages[id]\\n    if (typeof translated === 'string') {\\n      translated = messages[id] = { message: translated }\\n    }\\n    if (!translated) {\\n      var message = 'Translation for \\\"' + id + '\\\" in \\\"' + locale + '\\\" is missing'\\n      if (missingTranslation === 'warning') {\\n        /* istanbul ignore else */\\n        if (typeof console !== 'undefined') console.warn(message)\\n      } else if (missingTranslation !== 'ignore') { // 'error'\\n        throw new Error(message)\\n      }\\n      var replacement = typeof missingReplacement === 'function'\\n        ? missingReplacement(pattern, id, locale) || pattern\\n        : missingReplacement || pattern\\n      translated = messages[id] = { message: replacement }\\n    }\\n    return translated\\n  }\\n\\n  formatMessage.setup = function setup (opt/*:: ?: Options */) {\\n    opt = opt || {}\\n    if (opt.locale) currentLocales = opt.locale\\n    if ('translations' in opt) translations = opt.translations || {}\\n    if (opt.generateId) generateId = opt.generateId\\n    if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement\\n    if (opt.missingTranslation) missingTranslation = opt.missingTranslation\\n    if (opt.formats) {\\n      if (opt.formats.number) assign(formats.number, opt.formats.number)\\n      if (opt.formats.date) assign(formats.date, opt.formats.date)\\n      if (opt.formats.time) assign(formats.time, opt.formats.time)\\n    }\\n    if (opt.types) {\\n      types = opt.types\\n      types[tagsType] = richType\\n    }\\n    return {\\n      locale: currentLocales,\\n      translations: translations,\\n      generateId: generateId,\\n      missingReplacement: missingReplacement,\\n      missingTranslation: missingTranslation,\\n      formats: formats,\\n      types: types\\n    }\\n  }\\n\\n  formatMessage.number = function (value/*: number */, style/*:: ?: string */, locales/*:: ?: Locales */) {\\n    var options = (style && formats.number[style]) ||\\n      formats.parseNumberPattern(style) ||\\n      formats.number.default\\n    return new Intl.NumberFormat(locales || currentLocales, options).format(value)\\n  }\\n\\n  formatMessage.date = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {\\n    var options = (style && formats.date[style]) ||\\n      formats.parseDatePattern(style) ||\\n      formats.date.default\\n    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)\\n  }\\n\\n  formatMessage.time = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {\\n    var options = (style && formats.time[style]) ||\\n      formats.parseDatePattern(style) ||\\n      formats.time.default\\n    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)\\n  }\\n\\n  formatMessage.select = function (value/*: any */, options/*: Object */) {\\n    return options[value] || options.other\\n  }\\n\\n  formatMessage.custom = function (placeholder/*: any[] */, locales/*: Locales */, value/*: any */, args/*: Object */) {\\n    if (!(placeholder[1] in types)) return value\\n    return types[placeholder[1]](placeholder, locales)(value, args)\\n  }\\n\\n  formatMessage.plural = plural.bind(null, 'cardinal')\\n  formatMessage.selectordinal = plural.bind(null, 'ordinal')\\n  function plural (\\n    pluralType/*: 'cardinal' | 'ordinal' */,\\n    value/*: number */,\\n    offset/*: any */,\\n    options/*: any */,\\n    locale/*: any */\\n  ) {\\n    if (typeof offset === 'object' && typeof options !== 'object') { // offset is optional\\n      locale = options\\n      options = offset\\n      offset = 0\\n    }\\n    var closest = lookupClosestLocale(locale || currentLocales, plurals)\\n    var plural = (closest && plurals[closest][pluralType]) || returnOther\\n    return options['=' + +value] || options[plural(value - offset)] || options.other\\n  }\\n  function returnOther (/*:: n:number */) { return 'other' }\\n\\n  formatMessage.namespace = namespace\\n\\n  return formatMessage\\n}\\n\\nmodule.exports = exports = namespace()\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message/node_modules/format-message-formats/index.js\\\":\\n/*!**********************************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message/node_modules/format-message-formats/index.js ***!\\n  \\\\**********************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n// @flow\\nvar LONG = 'long'\\nvar SHORT = 'short'\\nvar NARROW = 'narrow'\\nvar NUMERIC = 'numeric'\\nvar TWODIGIT = '2-digit'\\n\\n/**\\n * formatting information\\n **/\\nmodule.exports = {\\n  number: {\\n    decimal: {\\n      style: 'decimal'\\n    },\\n    integer: {\\n      style: 'decimal',\\n      maximumFractionDigits: 0\\n    },\\n    currency: {\\n      style: 'currency',\\n      currency: 'USD'\\n    },\\n    percent: {\\n      style: 'percent'\\n    },\\n    default: {\\n      style: 'decimal'\\n    }\\n  },\\n  date: {\\n    short: {\\n      month: NUMERIC,\\n      day: NUMERIC,\\n      year: TWODIGIT\\n    },\\n    medium: {\\n      month: SHORT,\\n      day: NUMERIC,\\n      year: NUMERIC\\n    },\\n    long: {\\n      month: LONG,\\n      day: NUMERIC,\\n      year: NUMERIC\\n    },\\n    full: {\\n      month: LONG,\\n      day: NUMERIC,\\n      year: NUMERIC,\\n      weekday: LONG\\n    },\\n    default: {\\n      month: SHORT,\\n      day: NUMERIC,\\n      year: NUMERIC\\n    }\\n  },\\n  time: {\\n    short: {\\n      hour: NUMERIC,\\n      minute: NUMERIC\\n    },\\n    medium: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC\\n    },\\n    long: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC,\\n      timeZoneName: SHORT\\n    },\\n    full: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC,\\n      timeZoneName: SHORT\\n    },\\n    default: {\\n      hour: NUMERIC,\\n      minute: NUMERIC,\\n      second: NUMERIC\\n    }\\n  },\\n  duration: {\\n    default: {\\n      hours: {\\n        minimumIntegerDigits: 1,\\n        maximumFractionDigits: 0\\n      },\\n      minutes: {\\n        minimumIntegerDigits: 2,\\n        maximumFractionDigits: 0\\n      },\\n      seconds: {\\n        minimumIntegerDigits: 2,\\n        maximumFractionDigits: 3\\n      }\\n    }\\n  },\\n  parseNumberPattern: function (pattern/*: ?string */) {\\n    if (!pattern) return\\n    var options = {}\\n    var currency = pattern.match(/\\\\b[A-Z]{3}\\\\b/i)\\n    var syms = pattern.replace(/[^¤]/g, '').length\\n    if (!syms && currency) syms = 1\\n    if (syms) {\\n      options.style = 'currency'\\n      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name'\\n      options.currency = currency ? currency[0].toUpperCase() : 'USD'\\n    } else if (pattern.indexOf('%') >= 0) {\\n      options.style = 'percent'\\n    }\\n    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined\\n    options.useGrouping = pattern.indexOf(',') >= 0\\n    if (/E\\\\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {\\n      var size = pattern.replace(/E\\\\+?[@#0]+|[^@#0]/gi, '')\\n      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21)\\n      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21)\\n    } else {\\n      var parts = pattern.replace(/[^#0.]/g, '').split('.')\\n      var integer = parts[0]\\n      var n = integer.length - 1\\n      while (integer[n] === '0') --n\\n      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21)\\n      var fraction = parts[1] || ''\\n      n = 0\\n      while (fraction[n] === '0') ++n\\n      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20)\\n      while (fraction[n] === '#') ++n\\n      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20)\\n    }\\n    return options\\n  },\\n  parseDatePattern: function (pattern/*: ?string */) {\\n    if (!pattern) return\\n    var options = {}\\n    for (var i = 0; i < pattern.length;) {\\n      var current = pattern[i]\\n      var n = 1\\n      while (pattern[++i] === current) ++n\\n      switch (current) {\\n        case 'G':\\n          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT\\n          break\\n        case 'y':\\n        case 'Y':\\n          options.year = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'M':\\n        case 'L':\\n          n = Math.min(Math.max(n - 1, 0), 4)\\n          options.month = [ NUMERIC, TWODIGIT, SHORT, LONG, NARROW ][n]\\n          break\\n        case 'E':\\n        case 'e':\\n        case 'c':\\n          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT\\n          break\\n        case 'd':\\n        case 'D':\\n          options.day = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'h':\\n        case 'K':\\n          options.hour12 = true\\n          options.hour = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'H':\\n        case 'k':\\n          options.hour12 = false\\n          options.hour = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'm':\\n          options.minute = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 's':\\n        case 'S':\\n          options.second = n === 2 ? TWODIGIT : NUMERIC\\n          break\\n        case 'z':\\n        case 'Z':\\n        case 'v':\\n        case 'V':\\n          options.timeZoneName = n === 1 ? SHORT : LONG\\n          break\\n      }\\n    }\\n    return Object.keys(options).length ? options : undefined\\n  }\\n}\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message/node_modules/format-message-parse/index.js\\\":\\n/*!********************************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message/node_modules/format-message-parse/index.js ***!\\n  \\\\********************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n// @flow\\n\\n\\n/*::\\nexport type AST = Element[]\\nexport type Element = string | Placeholder\\nexport type Placeholder = Plural | Styled | Typed | Simple\\nexport type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]\\nexport type Styled = [ string, string, string | SubMessages ]\\nexport type Typed = [ string, string ]\\nexport type Simple = [ string ]\\nexport type SubMessages = { [string]: AST }\\nexport type Token = [ TokenType, string ]\\nexport type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'\\ntype Context = {|\\n  pattern: string,\\n  index: number,\\n  tagsType: ?string,\\n  tokens: ?Token[]\\n|}\\n*/\\n\\nvar ARG_OPN = '{'\\nvar ARG_CLS = '}'\\nvar ARG_SEP = ','\\nvar NUM_ARG = '#'\\nvar TAG_OPN = '<'\\nvar TAG_CLS = '>'\\nvar TAG_END = '</'\\nvar TAG_SELF_CLS = '/>'\\nvar ESC = '\\\\''\\nvar OFFSET = 'offset:'\\nvar simpleTypes = [\\n  'number',\\n  'date',\\n  'time',\\n  'ordinal',\\n  'duration',\\n  'spellout'\\n]\\nvar submTypes = [\\n  'plural',\\n  'select',\\n  'selectordinal'\\n]\\n\\n/**\\n * parse\\n *\\n * Turns this:\\n *  `You have { numBananas, plural,\\n *       =0 {no bananas}\\n *      one {a banana}\\n *    other {# bananas}\\n *  } for sale`\\n *\\n * into this:\\n *  [ \\\"You have \\\", [ \\\"numBananas\\\", \\\"plural\\\", 0, {\\n *       \\\"=0\\\": [ \\\"no bananas\\\" ],\\n *      \\\"one\\\": [ \\\"a banana\\\" ],\\n *    \\\"other\\\": [ [ '#' ], \\\" bananas\\\" ]\\n *  } ], \\\" for sale.\\\" ]\\n *\\n * tokens:\\n *  [\\n *    [ \\\"text\\\", \\\"You have \\\" ],\\n *    [ \\\"syntax\\\", \\\"{\\\" ],\\n *    [ \\\"space\\\", \\\" \\\" ],\\n *    [ \\\"id\\\", \\\"numBananas\\\" ],\\n *    [ \\\"syntax\\\", \\\", \\\" ],\\n *    [ \\\"space\\\", \\\" \\\" ],\\n *    [ \\\"type\\\", \\\"plural\\\" ],\\n *    [ \\\"syntax\\\", \\\",\\\" ],\\n *    [ \\\"space\\\", \\\"\\\\n     \\\" ],\\n *    [ \\\"selector\\\", \\\"=0\\\" ],\\n *    [ \\\"space\\\", \\\" \\\" ],\\n *    [ \\\"syntax\\\", \\\"{\\\" ],\\n *    [ \\\"text\\\", \\\"no bananas\\\" ],\\n *    [ \\\"syntax\\\", \\\"}\\\" ],\\n *    [ \\\"space\\\", \\\"\\\\n    \\\" ],\\n *    [ \\\"selector\\\", \\\"one\\\" ],\\n *    [ \\\"space\\\", \\\" \\\" ],\\n *    [ \\\"syntax\\\", \\\"{\\\" ],\\n *    [ \\\"text\\\", \\\"a banana\\\" ],\\n *    [ \\\"syntax\\\", \\\"}\\\" ],\\n *    [ \\\"space\\\", \\\"\\\\n  \\\" ],\\n *    [ \\\"selector\\\", \\\"other\\\" ],\\n *    [ \\\"space\\\", \\\" \\\" ],\\n *    [ \\\"syntax\\\", \\\"{\\\" ],\\n *    [ \\\"syntax\\\", \\\"#\\\" ],\\n *    [ \\\"text\\\", \\\" bananas\\\" ],\\n *    [ \\\"syntax\\\", \\\"}\\\" ],\\n *    [ \\\"space\\\", \\\"\\\\n\\\" ],\\n *    [ \\\"syntax\\\", \\\"}\\\" ],\\n *    [ \\\"text\\\", \\\" for sale.\\\" ]\\n *  ]\\n **/\\nexports = module.exports = function parse (\\n  pattern/*: string */,\\n  options/*:: ?: { tagsType?: string, tokens?: Token[] } */\\n)/*: AST */ {\\n  return parseAST({\\n    pattern: String(pattern),\\n    index: 0,\\n    tagsType: (options && options.tagsType) || null,\\n    tokens: (options && options.tokens) || null\\n  }, '')\\n}\\n\\nfunction parseAST (current/*: Context */, parentType/*: string */)/*: AST */ {\\n  var pattern = current.pattern\\n  var length = pattern.length\\n  var elements/*: AST */ = []\\n  var start = current.index\\n  var text = parseText(current, parentType)\\n  if (text) elements.push(text)\\n  if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ])\\n  while (current.index < length) {\\n    if (pattern[current.index] === ARG_CLS) {\\n      if (!parentType) throw expected(current)\\n      break\\n    }\\n    if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break\\n    elements.push(parsePlaceholder(current))\\n    start = current.index\\n    text = parseText(current, parentType)\\n    if (text) elements.push(text)\\n    if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ])\\n  }\\n  return elements\\n}\\n\\nfunction parseText (current/*: Context */, parentType/*: string */)/*: string */ {\\n  var pattern = current.pattern\\n  var length = pattern.length\\n  var isHashSpecial = (parentType === 'plural' || parentType === 'selectordinal')\\n  var isAngleSpecial = !!current.tagsType\\n  var isArgStyle = (parentType === '{style}')\\n  var text = ''\\n  while (current.index < length) {\\n    var char = pattern[current.index]\\n    if (\\n      char === ARG_OPN || char === ARG_CLS ||\\n      (isHashSpecial && char === NUM_ARG) ||\\n      (isAngleSpecial && char === TAG_OPN) ||\\n      (isArgStyle && isWhitespace(char.charCodeAt(0)))\\n    ) {\\n      break\\n    } else if (char === ESC) {\\n      char = pattern[++current.index]\\n      if (char === ESC) { // double is always 1 '\\n        text += char\\n        ++current.index\\n      } else if (\\n        // only when necessary\\n        char === ARG_OPN || char === ARG_CLS ||\\n        (isHashSpecial && char === NUM_ARG) ||\\n        (isAngleSpecial && char === TAG_OPN) ||\\n        isArgStyle\\n      ) {\\n        text += char\\n        while (++current.index < length) {\\n          char = pattern[current.index]\\n          if (char === ESC && pattern[current.index + 1] === ESC) { // double is always 1 '\\n            text += ESC\\n            ++current.index\\n          } else if (char === ESC) { // end of quoted\\n            ++current.index\\n            break\\n          } else {\\n            text += char\\n          }\\n        }\\n      } else { // lone ' is just a '\\n        text += ESC\\n        // already incremented\\n      }\\n    } else {\\n      text += char\\n      ++current.index\\n    }\\n  }\\n  return text\\n}\\n\\nfunction isWhitespace (code/*: number */)/*: boolean */ {\\n  return (\\n    (code >= 0x09 && code <= 0x0D) ||\\n    code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E ||\\n    (code >= 0x2000 && code <= 0x200D) ||\\n    code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F ||\\n    code === 0x2060 || code === 0x3000 || code === 0xFEFF\\n  )\\n}\\n\\nfunction skipWhitespace (current/*: Context */)/*: void */ {\\n  var pattern = current.pattern\\n  var length = pattern.length\\n  var start = current.index\\n  while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {\\n    ++current.index\\n  }\\n  if (start < current.index && current.tokens) {\\n    current.tokens.push([ 'space', current.pattern.slice(start, current.index) ])\\n  }\\n}\\n\\nfunction parsePlaceholder (current/*: Context */)/*: Placeholder */ {\\n  var pattern = current.pattern\\n  if (pattern[current.index] === NUM_ARG) {\\n    if (current.tokens) current.tokens.push([ 'syntax', NUM_ARG ])\\n    ++current.index // move passed #\\n    return [ NUM_ARG ]\\n  }\\n\\n  var tag = parseTag(current)\\n  if (tag) return tag\\n\\n  /* istanbul ignore if should be unreachable if parseAST and parseText are right */\\n  if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN)\\n  if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ])\\n  ++current.index // move passed {\\n  skipWhitespace(current)\\n\\n  var id = parseId(current)\\n  if (!id) throw expected(current, 'placeholder id')\\n  if (current.tokens) current.tokens.push([ 'id', id ])\\n  skipWhitespace(current)\\n\\n  var char = pattern[current.index]\\n  if (char === ARG_CLS) { // end placeholder\\n    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])\\n    ++current.index // move passed }\\n    return [ id ]\\n  }\\n\\n  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)\\n  if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ])\\n  ++current.index // move passed ,\\n  skipWhitespace(current)\\n\\n  var type = parseId(current)\\n  if (!type) throw expected(current, 'placeholder type')\\n  if (current.tokens) current.tokens.push([ 'type', type ])\\n  skipWhitespace(current)\\n  char = pattern[current.index]\\n  if (char === ARG_CLS) { // end placeholder\\n    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])\\n    if (type === 'plural' || type === 'selectordinal' || type === 'select') {\\n      throw expected(current, type + ' sub-messages')\\n    }\\n    ++current.index // move passed }\\n    return [ id, type ]\\n  }\\n\\n  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)\\n  if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ])\\n  ++current.index // move passed ,\\n  skipWhitespace(current)\\n\\n  var arg\\n  if (type === 'plural' || type === 'selectordinal') {\\n    var offset = parsePluralOffset(current)\\n    skipWhitespace(current)\\n    arg = [ id, type, offset, parseSubMessages(current, type) ]\\n  } else if (type === 'select') {\\n    arg = [ id, type, parseSubMessages(current, type) ]\\n  } else if (simpleTypes.indexOf(type) >= 0) {\\n    arg = [ id, type, parseSimpleFormat(current) ]\\n  } else { // custom placeholder type\\n    var index = current.index\\n    var format/*: string | SubMessages */ = parseSimpleFormat(current)\\n    skipWhitespace(current)\\n    if (pattern[current.index] === ARG_OPN) {\\n      current.index = index // rewind, since should have been submessages\\n      format = parseSubMessages(current, type)\\n    }\\n    arg = [ id, type, format ]\\n  }\\n\\n  skipWhitespace(current)\\n  if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS)\\n  if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])\\n  ++current.index // move passed }\\n  return arg\\n}\\n\\nfunction parseTag (current/*: Context */)/*: ?Placeholder */ {\\n  var tagsType = current.tagsType\\n  if (!tagsType || current.pattern[current.index] !== TAG_OPN) return\\n\\n  if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {\\n    throw expected(current, null, 'closing tag without matching opening tag')\\n  }\\n  if (current.tokens) current.tokens.push([ 'syntax', TAG_OPN ])\\n  ++current.index // move passed <\\n\\n  var id = parseId(current, true)\\n  if (!id) throw expected(current, 'placeholder id')\\n  if (current.tokens) current.tokens.push([ 'id', id ])\\n  skipWhitespace(current)\\n\\n  if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {\\n    if (current.tokens) current.tokens.push([ 'syntax', TAG_SELF_CLS ])\\n    current.index += TAG_SELF_CLS.length\\n    return [ id, tagsType ]\\n  }\\n  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)\\n  if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ])\\n  ++current.index // move passed >\\n\\n  var children = parseAST(current, tagsType)\\n\\n  var end = current.index\\n  if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS)\\n  if (current.tokens) current.tokens.push([ 'syntax', TAG_END ])\\n  current.index += TAG_END.length\\n  var closeId = parseId(current, true)\\n  if (closeId && current.tokens) current.tokens.push([ 'id', closeId ])\\n  if (id !== closeId) {\\n    current.index = end // rewind for better error message\\n    throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS)\\n  }\\n  skipWhitespace(current)\\n  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)\\n  if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ])\\n  ++current.index // move passed >\\n\\n  return [ id, tagsType, { children: children } ]\\n}\\n\\nfunction parseId (current/*: Context */, isTag/*:: ?: boolean */)/*: string */ {\\n  var pattern = current.pattern\\n  var length = pattern.length\\n  var id = ''\\n  while (current.index < length) {\\n    var char = pattern[current.index]\\n    if (\\n      char === ARG_OPN || char === ARG_CLS || char === ARG_SEP ||\\n      char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) ||\\n      (isTag && (char === TAG_OPN || char === TAG_CLS || char === '/'))\\n    ) break\\n    id += char\\n    ++current.index\\n  }\\n  return id\\n}\\n\\nfunction parseSimpleFormat (current/*: Context */)/*: string */ {\\n  var start = current.index\\n  var style = parseText(current, '{style}')\\n  if (!style) throw expected(current, 'placeholder style name')\\n  if (current.tokens) current.tokens.push([ 'style', current.pattern.slice(start, current.index) ])\\n  return style\\n}\\n\\nfunction parsePluralOffset (current/*: Context */)/*: number */ {\\n  var pattern = current.pattern\\n  var length = pattern.length\\n  var offset = 0\\n  if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {\\n    if (current.tokens) current.tokens.push([ 'offset', 'offset' ], [ 'syntax', ':' ])\\n    current.index += OFFSET.length // move passed offset:\\n    skipWhitespace(current)\\n    var start = current.index\\n    while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {\\n      ++current.index\\n    }\\n    if (start === current.index) throw expected(current, 'offset number')\\n    if (current.tokens) current.tokens.push([ 'number', pattern.slice(start, current.index) ])\\n    offset = +pattern.slice(start, current.index)\\n  }\\n  return offset\\n}\\n\\nfunction isDigit (code/*: number */)/*: boolean */ {\\n  return (code >= 0x30 && code <= 0x39)\\n}\\n\\nfunction parseSubMessages (current/*: Context */, parentType/*: string */)/*: SubMessages */ {\\n  var pattern = current.pattern\\n  var length = pattern.length\\n  var options/*: SubMessages */ = {}\\n  while (current.index < length && pattern[current.index] !== ARG_CLS) {\\n    var selector = parseId(current)\\n    if (!selector) throw expected(current, 'sub-message selector')\\n    if (current.tokens) current.tokens.push([ 'selector', selector ])\\n    skipWhitespace(current)\\n    options[selector] = parseSubMessage(current, parentType)\\n    skipWhitespace(current)\\n  }\\n  if (!options.other && submTypes.indexOf(parentType) >= 0) {\\n    throw expected(current, null, null, '\\\"other\\\" sub-message must be specified in ' + parentType)\\n  }\\n  return options\\n}\\n\\nfunction parseSubMessage (current/*: Context */, parentType/*: string */)/*: AST */ {\\n  if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message')\\n  if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ])\\n  ++current.index // move passed {\\n  var message = parseAST(current, parentType)\\n  if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message')\\n  if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ])\\n  ++current.index // move passed }\\n  return message\\n}\\n\\nfunction expected (current/*: Context */, expected/*:: ?: ?string */, found/*:: ?: ?string */, message/*:: ?: string */) {\\n  var pattern = current.pattern\\n  var lines = pattern.slice(0, current.index).split(/\\\\r?\\\\n/)\\n  var offset = current.index\\n  var line = lines.length\\n  var column = lines.slice(-1)[0].length\\n  found = found || (\\n    (current.index >= pattern.length) ? 'end of message pattern'\\n      : (parseId(current) || pattern[current.index])\\n  )\\n  if (!message) message = errorMessage(expected, found)\\n  message += ' in ' + pattern.replace(/\\\\r?\\\\n/g, '\\\\n')\\n  return new SyntaxError(message, expected, found, offset, line, column)\\n}\\n\\nfunction errorMessage (expected/*: ?string */, found/* string */) {\\n  if (!expected) return 'Unexpected ' + found + ' found'\\n  return 'Expected ' + expected + ' but found ' + found\\n}\\n\\n/**\\n * SyntaxError\\n *  Holds information about bad syntax found in a message pattern\\n **/\\nfunction SyntaxError (message/*: string */, expected/*: ?string */, found/*: ?string */, offset/*: number */, line/*: number */, column/*: number */) {\\n  Error.call(this, message)\\n  this.name = 'SyntaxError'\\n  this.message = message\\n  this.expected = expected\\n  this.found = found\\n  this.offset = offset\\n  this.line = line\\n  this.column = column\\n}\\nSyntaxError.prototype = Object.create(Error.prototype)\\nexports.SyntaxError = SyntaxError\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/format-message/node_modules/lookup-closest-locale/index.js\\\":\\n/*!*********************************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/format-message/node_modules/lookup-closest-locale/index.js ***!\\n  \\\\*********************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n// @flow\\n// \\\"lookup\\\" algorithm http://tools.ietf.org/html/rfc4647#section-3.4\\n// assumes normalized language tags, and matches in a case sensitive manner\\nmodule.exports = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {\\n  if (typeof locale === 'string' && available[locale]) return locale\\n  var locales = [].concat(locale || [])\\n  for (var l = 0, ll = locales.length; l < ll; ++l) {\\n    var current = locales[l].split('-')\\n    while (current.length) {\\n      var candidate = current.join('-')\\n      if (available[candidate]) return candidate\\n      current.pop()\\n    }\\n  }\\n}\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/microee/index.js\\\":\\n/*!***************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/microee/index.js ***!\\n  \\\\***************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\nfunction M() { this._events = {}; }\\nM.prototype = {\\n  on: function(ev, cb) {\\n    this._events || (this._events = {});\\n    var e = this._events;\\n    (e[ev] || (e[ev] = [])).push(cb);\\n    return this;\\n  },\\n  removeListener: function(ev, cb) {\\n    var e = this._events[ev] || [], i;\\n    for(i = e.length-1; i >= 0 && e[i]; i--){\\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\\n    }\\n  },\\n  removeAllListeners: function(ev) {\\n    if(!ev) { this._events = {}; }\\n    else { this._events[ev] && (this._events[ev] = []); }\\n  },\\n  listeners: function(ev) {\\n    return (this._events ? this._events[ev] || [] : []);\\n  },\\n  emit: function(ev) {\\n    this._events || (this._events = {});\\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\\n    for(i = e.length-1; i >= 0 && e[i]; i--){\\n      e[i].apply(this, args);\\n    }\\n    return this;\\n  },\\n  when: function(ev, cb) {\\n    return this.once(ev, cb, true);\\n  },\\n  once: function(ev, cb, when) {\\n    if(!cb) return this;\\n    function c() {\\n      if(!when) this.removeListener(ev, c);\\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\\n    }\\n    c.cb = cb;\\n    this.on(ev, c);\\n    return this;\\n  }\\n};\\nM.mixin = function(dest) {\\n  var o = M.prototype, k;\\n  for (k in o) {\\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\\n  }\\n};\\nmodule.exports = M;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/filter.js\\\":\\n/*!***************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/common/filter.js ***!\\n  \\\\***************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n// default filter\\nvar Transform = __webpack_require__(/*! ./transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\");\\n\\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\\n\\nfunction Filter() {\\n  this.enabled = true;\\n  this.defaultResult = true;\\n  this.clear();\\n}\\n\\nTransform.mixin(Filter);\\n\\n// allow all matching, with level >= given level\\nFilter.prototype.allow = function(name, level) {\\n  this._white.push({ n: name, l: levelMap[level] });\\n  return this;\\n};\\n\\n// deny all matching, with level <= given level\\nFilter.prototype.deny = function(name, level) {\\n  this._black.push({ n: name, l: levelMap[level] });\\n  return this;\\n};\\n\\nFilter.prototype.clear = function() {\\n  this._white = [];\\n  this._black = [];\\n  return this;\\n};\\n\\nfunction test(rule, name) {\\n  // use .test for RegExps\\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\\n};\\n\\nFilter.prototype.test = function(name, level) {\\n  var i, len = Math.max(this._white.length, this._black.length);\\n  for(i = 0; i < len; i++) {\\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\\n      return true;\\n    }\\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\\n      return false;\\n    }\\n  }\\n  return this.defaultResult;\\n};\\n\\nFilter.prototype.write = function(name, level, args) {\\n  if(!this.enabled || this.test(name, level)) {\\n    return this.emit('item', name, level, args);\\n  }\\n};\\n\\nmodule.exports = Filter;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/minilog.js\\\":\\n/*!****************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/common/minilog.js ***!\\n  \\\\****************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ./transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\"),\\n    Filter = __webpack_require__(/*! ./filter.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/filter.js\\\");\\n\\nvar log = new Transform(),\\n    slice = Array.prototype.slice;\\n\\nexports = module.exports = function create(name) {\\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\\n  o.suggest = exports.suggest;\\n  o.format = log.format;\\n  return o;\\n};\\n\\n// filled in separately\\nexports.defaultBackend = exports.defaultFormatter = null;\\n\\nexports.pipe = function(dest) {\\n  return log.pipe(dest);\\n};\\n\\nexports.end = exports.unpipe = exports.disable = function(from) {\\n  return log.unpipe(from);\\n};\\n\\nexports.Transform = Transform;\\nexports.Filter = Filter;\\n// this is the default filter that's applied when .enable() is called normally\\n// you can bypass it completely and set up your own pipes\\nexports.suggest = new Filter();\\n\\nexports.enable = function() {\\n  if(exports.defaultFormatter) {\\n    return log.pipe(exports.suggest) // filter\\n              .pipe(exports.defaultFormatter) // formatter\\n              .pipe(exports.defaultBackend); // backend\\n  }\\n  return log.pipe(exports.suggest) // filter\\n            .pipe(exports.defaultBackend); // formatter\\n};\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\":\\n/*!******************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js ***!\\n  \\\\******************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar microee = __webpack_require__(/*! microee */ \\\"./node_modules/scratch-vm/node_modules/microee/index.js\\\");\\n\\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\\nfunction Transform() {}\\n\\nmicroee.mixin(Transform);\\n\\n// The write() signature is different from Node's\\n// --> makes it much easier to work with objects in logs.\\n// One of the lessons from v1 was that it's better to target\\n// a good browser rather than the lowest common denominator\\n// internally.\\n// If you want to use external streams, pipe() to ./stringify.js first.\\nTransform.prototype.write = function(name, level, args) {\\n  this.emit('item', name, level, args);\\n};\\n\\nTransform.prototype.end = function() {\\n  this.emit('end');\\n  this.removeAllListeners();\\n};\\n\\nTransform.prototype.pipe = function(dest) {\\n  var s = this;\\n  // prevent double piping\\n  s.emit('unpipe', dest);\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', s);\\n\\n  function onItem() {\\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\\n  }\\n  function onEnd() { !dest._isStdio && dest.end(); }\\n\\n  s.on('item', onItem);\\n  s.on('end', onEnd);\\n\\n  s.when('unpipe', function(from) {\\n    var match = (from === dest) || typeof from == 'undefined';\\n    if(match) {\\n      s.removeListener('item', onItem);\\n      s.removeListener('end', onEnd);\\n      dest.emit('unpipe');\\n    }\\n    return match;\\n  });\\n\\n  return dest;\\n};\\n\\nTransform.prototype.unpipe = function(from) {\\n  this.emit('unpipe', from);\\n  return this;\\n};\\n\\nTransform.prototype.format = function(dest) {\\n  throw new Error([\\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\\n    'var Minilog = require(\\\\'minilog\\\\');',\\n    'Minilog',\\n    '  .pipe(Minilog.backends.console.formatClean)',\\n    '  .pipe(Minilog.backends.console);'].join('\\\\n'));\\n};\\n\\nTransform.mixin = function(dest) {\\n  var o = Transform.prototype, k;\\n  for (k in o) {\\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\\n  }\\n};\\n\\nmodule.exports = Transform;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/array.js\\\":\\n/*!***********************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/array.js ***!\\n  \\\\***********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\"),\\n    cache = [ ];\\n\\nvar logger = new Transform();\\n\\nlogger.write = function(name, level, args) {\\n  cache.push([ name, level, args ]);\\n};\\n\\n// utility functions\\nlogger.get = function() { return cache; };\\nlogger.empty = function() { cache = []; };\\n\\nmodule.exports = logger;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/console.js\\\":\\n/*!*************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/console.js ***!\\n  \\\\*************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\");\\n\\nvar newlines = /\\\\n+$/,\\n    logger = new Transform();\\n\\nlogger.write = function(name, level, args) {\\n  var i = args.length-1;\\n  if (typeof console === 'undefined' || !console.log) {\\n    return;\\n  }\\n  if(console.log.apply) {\\n    return console.log.apply(console, [name, level].concat(args));\\n  } else if(JSON && JSON.stringify) {\\n    // console.log.apply is undefined in IE8 and IE9\\n    // for IE8/9: make console.log at least a bit less awful\\n    if(args[i] && typeof args[i] == 'string') {\\n      args[i] = args[i].replace(newlines, '');\\n    }\\n    try {\\n      for(i = 0; i < args.length; i++) {\\n        args[i] = JSON.stringify(args[i]);\\n      }\\n    } catch(e) {}\\n    console.log(args.join(' '));\\n  }\\n};\\n\\nlogger.formatters = ['color', 'minilog'];\\nlogger.color = __webpack_require__(/*! ./formatters/color.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/color.js\\\");\\nlogger.minilog = __webpack_require__(/*! ./formatters/minilog.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js\\\");\\n\\nmodule.exports = logger;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/color.js\\\":\\n/*!**********************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/color.js ***!\\n  \\\\**********************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ../../common/transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\"),\\n    color = __webpack_require__(/*! ./util.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/util.js\\\");\\n\\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\\n    logger = new Transform();\\n\\nlogger.write = function(name, level, args) {\\n  var fn = console.log;\\n  if(console[level] && console[level].apply) {\\n    fn = console[level];\\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\\n  }\\n};\\n\\n// NOP, because piping the formatted logs can only cause trouble.\\nlogger.pipe = function() { };\\n\\nmodule.exports = logger;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js\\\":\\n/*!************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js ***!\\n  \\\\************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ../../common/transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\"),\\n    color = __webpack_require__(/*! ./util.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/util.js\\\"),\\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\\n    logger = new Transform();\\n\\nlogger.write = function(name, level, args) {\\n  var fn = console.log;\\n  if(level != 'debug' && console[level]) {\\n    fn = console[level];\\n  }\\n\\n  var subset = [], i = 0;\\n  if(level != 'info') {\\n    for(; i < args.length; i++) {\\n      if(typeof args[i] != 'string') break;\\n    }\\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\\n  } else {\\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\\n  }\\n};\\n\\n// NOP, because piping the formatted logs can only cause trouble.\\nlogger.pipe = function() { };\\n\\nmodule.exports = logger;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/util.js\\\":\\n/*!*********************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/util.js ***!\\n  \\\\*********************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\nvar hex = {\\n  black: '#000',\\n  red: '#c23621',\\n  green: '#25bc26',\\n  yellow: '#bbbb00',\\n  blue:  '#492ee1',\\n  magenta: '#d338d3',\\n  cyan: '#33bbc8',\\n  gray: '#808080',\\n  purple: '#708'\\n};\\nfunction color(fg, isInverse) {\\n  if(isInverse) {\\n    return 'color: #fff; background: '+hex[fg]+';';\\n  } else {\\n    return 'color: '+hex[fg]+';';\\n  }\\n}\\n\\nmodule.exports = color;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/index.js\\\":\\n/*!***********************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/index.js ***!\\n  \\\\***********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Minilog = __webpack_require__(/*! ../common/minilog.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/minilog.js\\\");\\n\\nvar oldEnable = Minilog.enable,\\n    oldDisable = Minilog.disable,\\n    isChrome = (typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent)),\\n    console = __webpack_require__(/*! ./console.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/console.js\\\");\\n\\n// Use a more capable logging backend if on Chrome\\nMinilog.defaultBackend = (isChrome ? console.minilog : console);\\n\\n// apply enable inputs from localStorage and from the URL\\nif(typeof window != 'undefined') {\\n  try {\\n    Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));\\n  } catch(e) {}\\n  if(window.location && window.location.search) {\\n    var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);\\n    match && Minilog.enable(decodeURIComponent(match[1]));\\n  }\\n}\\n\\n// Make enable also add to localStorage\\nMinilog.enable = function() {\\n  oldEnable.call(Minilog, true);\\n  try { window.localStorage['minilogSettings'] = JSON.stringify(true); } catch(e) {}\\n  return this;\\n};\\n\\nMinilog.disable = function() {\\n  oldDisable.call(Minilog);\\n  try { delete window.localStorage.minilogSettings; } catch(e) {}\\n  return this;\\n};\\n\\nexports = module.exports = Minilog;\\n\\nexports.backends = {\\n  array: __webpack_require__(/*! ./array.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/array.js\\\"),\\n  browser: Minilog.defaultBackend,\\n  localStorage: __webpack_require__(/*! ./localstorage.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/localstorage.js\\\"),\\n  jQuery: __webpack_require__(/*! ./jquery_simple.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/jquery_simple.js\\\")\\n};\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/jquery_simple.js\\\":\\n/*!*******************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/jquery_simple.js ***!\\n  \\\\*******************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\");\\n\\nvar cid = new Date().valueOf().toString(36);\\n\\nfunction AjaxLogger(options) {\\n  this.url = options.url || '';\\n  this.cache = [];\\n  this.timer = null;\\n  this.interval = options.interval || 30*1000;\\n  this.enabled = true;\\n  this.jQuery = window.jQuery;\\n  this.extras = {};\\n}\\n\\nTransform.mixin(AjaxLogger);\\n\\nAjaxLogger.prototype.write = function(name, level, args) {\\n  if(!this.timer) { this.init(); }\\n  this.cache.push([name, level].concat(args));\\n};\\n\\nAjaxLogger.prototype.init = function() {\\n  if(!this.enabled || !this.jQuery) return;\\n  var self = this;\\n  this.timer = setTimeout(function() {\\n    var i, logs = [], ajaxData, url = self.url;\\n    if(self.cache.length == 0) return self.init();\\n    // Test each log line and only log the ones that are valid (e.g. don't have circular references).\\n    // Slight performance hit but benefit is we log all valid lines.\\n    for(i = 0; i < self.cache.length; i++) {\\n      try {\\n        JSON.stringify(self.cache[i]);\\n        logs.push(self.cache[i]);\\n      } catch(e) { }\\n    }\\n    if(self.jQuery.isEmptyObject(self.extras)) {\\n        ajaxData = JSON.stringify({ logs: logs });\\n        url = self.url + '?client_id=' + cid;\\n    } else {\\n        ajaxData = JSON.stringify(self.jQuery.extend({logs: logs}, self.extras));\\n    }\\n\\n    self.jQuery.ajax(url, {\\n      type: 'POST',\\n      cache: false,\\n      processData: false,\\n      data: ajaxData,\\n      contentType: 'application/json',\\n      timeout: 10000\\n    }).success(function(data, status, jqxhr) {\\n      if(data.interval) {\\n        self.interval = Math.max(1000, data.interval);\\n      }\\n    }).error(function() {\\n      self.interval = 30000;\\n    }).always(function() {\\n      self.init();\\n    });\\n    self.cache = [];\\n  }, this.interval);\\n};\\n\\nAjaxLogger.prototype.end = function() {};\\n\\n// wait until jQuery is defined. Useful if you don't control the load order.\\nAjaxLogger.jQueryWait = function(onDone) {\\n  if(typeof window !== 'undefined' && (window.jQuery || window.$)) {\\n    return onDone(window.jQuery || window.$);\\n  } else if (typeof window !== 'undefined') {\\n    setTimeout(function() { AjaxLogger.jQueryWait(onDone); }, 200);\\n  }\\n};\\n\\nmodule.exports = AjaxLogger;\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/localstorage.js\\\":\\n/*!******************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/node_modules/minilog/lib/web/localstorage.js ***!\\n  \\\\******************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar Transform = __webpack_require__(/*! ../common/transform.js */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js\\\"),\\n    cache = false;\\n\\nvar logger = new Transform();\\n\\nlogger.write = function(name, level, args) {\\n  if(typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;\\n  try {\\n    if(!cache) { cache = (window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : []); }\\n    cache.push([ new Date().toString(), name, level, args ]);\\n    window.localStorage.minilog = JSON.stringify(cache);\\n  } catch(e) {}\\n};\\n\\nmodule.exports = logger;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/dispatch/shared-dispatch.js\\\":\\n/*!*****************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/dispatch/shared-dispatch.js ***!\\n  \\\\*****************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nconst log = __webpack_require__(/*! ../util/log */ \\\"./node_modules/scratch-vm/src/util/log.js\\\");\\n\\n/**\\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\\n * @property {string} service - the name of the service to be called\\n * @property {string} method - the name of the method to be called\\n * @property {Array|undefined} args - the arguments to be passed to the method\\n */\\n\\n/**\\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\\n * @property {*} responseId - a copy of the response ID from the call which generated this response\\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\\n */\\n\\n/**\\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\\n * Any message to the dispatch system.\\n */\\n\\n/**\\n * The SharedDispatch class is responsible for dispatch features shared by\\n * {@link CentralDispatch} and {@link WorkerDispatch}.\\n */\\nclass SharedDispatch {\\n  constructor() {\\n    /**\\n     * List of callback registrations for promises waiting for a response from a call to a service on another\\n     * worker. A callback registration is an array of [resolve,reject] Promise functions.\\n     * Calls to local services don't enter this list.\\n     * @type {Array.<Function[]>}\\n     */\\n    this.callbacks = [];\\n\\n    /**\\n     * The next response ID to be used.\\n     * @type {int}\\n     */\\n    this.nextResponseId = 0;\\n  }\\n\\n  /**\\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\\n   * transferred to the worker, and they should not be used after this call.\\n   * @example\\n   *      dispatcher.call('vm', 'setData', 'cat', 42);\\n   *      // this finds the worker for the 'vm' service, then on that worker calls:\\n   *      vm.setData('cat', 42);\\n   * @param {string} service - the name of the service.\\n   * @param {string} method - the name of the method.\\n   * @param {*} [args] - the arguments to be copied to the method, if any.\\n   * @returns {Promise} - a promise for the return value of the service method.\\n   */\\n  call(service, method) {\\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\\n      args[_key - 2] = arguments[_key];\\n    }\\n    return this.transferCall(service, method, null, ...args);\\n  }\\n\\n  /**\\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\\n   * transferred to the worker, and they should not be used after this call.\\n   * @example\\n   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);\\n   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:\\n   *      vm.setData('cat', myArrayBuffer);\\n   * @param {string} service - the name of the service.\\n   * @param {string} method - the name of the method.\\n   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\\n   * @param {*} [args] - the arguments to be copied to the method, if any.\\n   * @returns {Promise} - a promise for the return value of the service method.\\n   */\\n  transferCall(service, method, transfer) {\\n    try {\\n      const {\\n        provider,\\n        isRemote\\n      } = this._getServiceProvider(service);\\n      if (provider) {\\n        for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\\n          args[_key2 - 3] = arguments[_key2];\\n        }\\n        if (isRemote) {\\n          return this._remoteTransferCall(provider, service, method, transfer, ...args);\\n        }\\n        const result = provider[method].apply(provider, args);\\n        return Promise.resolve(result);\\n      }\\n      return Promise.reject(new Error(\\\"Service not found: \\\".concat(service)));\\n    } catch (e) {\\n      return Promise.reject(e);\\n    }\\n  }\\n\\n  /**\\n   * Check if a particular service lives on another worker.\\n   * @param {string} service - the service to check.\\n   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.\\n   * @private\\n   */\\n  _isRemoteService(service) {\\n    return this._getServiceProvider(service).isRemote;\\n  }\\n\\n  /**\\n   * Like {@link call}, but force the call to be posted through a particular communication channel.\\n   * @param {object} provider - send the call through this object's `postMessage` function.\\n   * @param {string} service - the name of the service.\\n   * @param {string} method - the name of the method.\\n   * @param {*} [args] - the arguments to be copied to the method, if any.\\n   * @returns {Promise} - a promise for the return value of the service method.\\n   */\\n  _remoteCall(provider, service, method) {\\n    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\\n      args[_key3 - 3] = arguments[_key3];\\n    }\\n    return this._remoteTransferCall(provider, service, method, null, ...args);\\n  }\\n\\n  /**\\n   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.\\n   * @param {object} provider - send the call through this object's `postMessage` function.\\n   * @param {string} service - the name of the service.\\n   * @param {string} method - the name of the method.\\n   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\\n   * @param {*} [args] - the arguments to be copied to the method, if any.\\n   * @returns {Promise} - a promise for the return value of the service method.\\n   */\\n  _remoteTransferCall(provider, service, method, transfer) {\\n    for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {\\n      args[_key4 - 4] = arguments[_key4];\\n    }\\n    return new Promise((resolve, reject) => {\\n      const responseId = this._storeCallbacks(resolve, reject);\\n\\n      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */\\n      // tw: upstream's logic is broken\\n      // Args is actually a 3 length list of [args, util, real block info]\\n      // We only want to send args. The others will throw errors when they try to be cloned\\n      if (args.length > 0 && typeof args[args.length - 1].func === 'function') {\\n        args.pop();\\n        args.pop();\\n      }\\n      if (transfer) {\\n        provider.postMessage({\\n          service,\\n          method,\\n          responseId,\\n          args\\n        }, transfer);\\n      } else {\\n        provider.postMessage({\\n          service,\\n          method,\\n          responseId,\\n          args\\n        });\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Store callback functions pending a response message.\\n   * @param {Function} resolve - function to call if the service method returns.\\n   * @param {Function} reject - function to call if the service method throws.\\n   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.\\n   * @protected\\n   */\\n  _storeCallbacks(resolve, reject) {\\n    const responseId = this.nextResponseId++;\\n    this.callbacks[responseId] = [resolve, reject];\\n    return responseId;\\n  }\\n\\n  /**\\n   * Deliver call response from a worker. This should only be called as the result of a message from a worker.\\n   * @param {int} responseId - the response ID of the callback set to call.\\n   * @param {DispatchResponseMessage} message - the message containing the response value(s).\\n   * @protected\\n   */\\n  _deliverResponse(responseId, message) {\\n    try {\\n      const [resolve, reject] = this.callbacks[responseId];\\n      delete this.callbacks[responseId];\\n      if (message.error) {\\n        reject(message.error);\\n      } else {\\n        resolve(message.result);\\n      }\\n    } catch (e) {\\n      log.error(\\\"Dispatch callback failed: \\\".concat(e));\\n    }\\n  }\\n\\n  /**\\n   * Handle a message event received from a connected worker.\\n   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.\\n   * @param {MessageEvent} event - the message event to be handled.\\n   * @protected\\n   */\\n  _onMessage(worker, event) {\\n    /** @type {DispatchMessage} */\\n    const message = event.data;\\n    message.args = message.args || [];\\n    let promise;\\n    if (message.service) {\\n      if (message.service === 'dispatch') {\\n        promise = this._onDispatchMessage(worker, message);\\n      } else {\\n        promise = this.call(message.service, message.method, ...message.args);\\n      }\\n    } else if (typeof message.responseId === 'undefined') {\\n      log.error(\\\"Dispatch caught malformed message from a worker: \\\".concat(JSON.stringify(event)));\\n    } else {\\n      this._deliverResponse(message.responseId, message);\\n    }\\n    if (promise) {\\n      if (typeof message.responseId === 'undefined') {\\n        log.error(\\\"Dispatch message missing required response ID: \\\".concat(JSON.stringify(event)));\\n      } else {\\n        promise.then(result => worker.postMessage({\\n          responseId: message.responseId,\\n          result\\n        }), error => worker.postMessage({\\n          responseId: message.responseId,\\n          error: \\\"\\\".concat(error)\\n        }));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Fetch the service provider object for a particular service name.\\n   * @abstract\\n   * @param {string} service - the name of the service to look up\\n   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\\n   * @protected\\n   */\\n  _getServiceProvider(service) {\\n    throw new Error(\\\"Could not get provider for \\\".concat(service, \\\": _getServiceProvider not implemented\\\"));\\n  }\\n\\n  /**\\n   * Handle a call message sent to the dispatch service itself\\n   * @abstract\\n   * @param {Worker} worker - the worker which sent the message.\\n   * @param {DispatchCallMessage} message - the message to be handled.\\n   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\\n   * @private\\n   */\\n  _onDispatchMessage(worker, message) {\\n    throw new Error(\\\"Unimplemented dispatch message handler cannot handle \\\".concat(message.method, \\\" method\\\"));\\n  }\\n}\\nmodule.exports = SharedDispatch;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/dispatch/worker-dispatch.js\\\":\\n/*!*****************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/dispatch/worker-dispatch.js ***!\\n  \\\\*****************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nconst SharedDispatch = __webpack_require__(/*! ./shared-dispatch */ \\\"./node_modules/scratch-vm/src/dispatch/shared-dispatch.js\\\");\\nconst log = __webpack_require__(/*! ../util/log */ \\\"./node_modules/scratch-vm/src/util/log.js\\\");\\nconst {\\n  centralDispatchService\\n} = __webpack_require__(/*! ../extension-support/tw-extension-worker-context */ \\\"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\\\");\\n\\n/**\\n * This class provides a Worker with the means to participate in the message dispatch system managed by CentralDispatch.\\n * From any context in the messaging system, the dispatcher's \\\"call\\\" method can call any method on any \\\"service\\\"\\n * provided in any participating context. The dispatch system will forward function arguments and return values across\\n * worker boundaries as needed.\\n * @see {CentralDispatch}\\n */\\nclass WorkerDispatch extends SharedDispatch {\\n  constructor() {\\n    super();\\n\\n    /**\\n     * This promise will be resolved when we have successfully connected to central dispatch.\\n     * @type {Promise}\\n     * @see {waitForConnection}\\n     * @private\\n     */\\n    this._connectionPromise = new Promise(resolve => {\\n      this._onConnect = resolve;\\n    });\\n\\n    /**\\n     * Map of service name to local service provider.\\n     * If a service is not listed here, it is assumed to be provided by another context (another Worker or the main\\n     * thread).\\n     * @see {setService}\\n     * @type {object}\\n     */\\n    this.services = {};\\n    this._onMessage = this._onMessage.bind(this, centralDispatchService);\\n    if (typeof self !== 'undefined') {\\n      self.onmessage = this._onMessage;\\n    }\\n  }\\n\\n  /**\\n   * @returns {Promise} a promise which will resolve upon connection to central dispatch. If you need to make a call\\n   * immediately on \\\"startup\\\" you can attach a 'then' to this promise.\\n   * @example\\n   *      dispatch.waitForConnection.then(() => {\\n   *          dispatch.call('myService', 'hello');\\n   *      })\\n   */\\n  get waitForConnection() {\\n    return this._connectionPromise;\\n  }\\n\\n  /**\\n   * Set a local object as the global provider of the specified service.\\n   * WARNING: Any method on the provider can be called from any worker within the dispatch system.\\n   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.\\n   * @param {object} provider - a local object which provides this service.\\n   * @returns {Promise} - a promise which will resolve once the service is registered.\\n   */\\n  setService(service, provider) {\\n    if (this.services.hasOwnProperty(service)) {\\n      log.warn(\\\"Worker dispatch replacing existing service provider for \\\".concat(service));\\n    }\\n    this.services[service] = provider;\\n    return this.waitForConnection.then(() => this._remoteCall(centralDispatchService, 'dispatch', 'setService', service));\\n  }\\n\\n  /**\\n   * Fetch the service provider object for a particular service name.\\n   * @override\\n   * @param {string} service - the name of the service to look up\\n   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\\n   * @protected\\n   */\\n  _getServiceProvider(service) {\\n    // if we don't have a local service by this name, contact central dispatch by calling `postMessage` on self\\n    const provider = this.services[service];\\n    return {\\n      provider: provider || centralDispatchService,\\n      isRemote: !provider\\n    };\\n  }\\n\\n  /**\\n   * Handle a call message sent to the dispatch service itself\\n   * @override\\n   * @param {Worker} worker - the worker which sent the message.\\n   * @param {DispatchCallMessage} message - the message to be handled.\\n   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\\n   * @protected\\n   */\\n  _onDispatchMessage(worker, message) {\\n    let promise;\\n    switch (message.method) {\\n      case 'handshake':\\n        promise = this._onConnect();\\n        break;\\n      case 'terminate':\\n        // Don't close until next tick, after sending confirmation back\\n        setTimeout(() => self.close(), 0);\\n        promise = Promise.resolve();\\n        break;\\n      default:\\n        log.error(\\\"Worker dispatch received message for unknown method: \\\".concat(message.method));\\n    }\\n    return promise;\\n  }\\n}\\nmodule.exports = new WorkerDispatch();\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/argument-type.js\\\":\\n/*!************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/argument-type.js ***!\\n  \\\\************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Block argument types\\n * @enum {string}\\n */\\nconst ArgumentType = {\\n  /**\\n   * Numeric value with angle picker\\n   */\\n  ANGLE: 'angle',\\n  /**\\n   * Boolean value with hexagonal placeholder\\n   */\\n  BOOLEAN: 'Boolean',\\n  /**\\n   * Numeric value with color picker\\n   */\\n  COLOR: 'color',\\n  /**\\n   * Numeric value with text field\\n   */\\n  NUMBER: 'number',\\n  /**\\n   * String value with text field\\n   */\\n  STRING: 'string',\\n  /**\\n   * String value with matrix field\\n   */\\n  MATRIX: 'matrix',\\n  /**\\n   * MIDI note number with note picker (piano) field\\n   */\\n  NOTE: 'note',\\n  /**\\n   * Inline image on block (as part of the label)\\n   */\\n  IMAGE: 'image',\\n  /**\\n   * Name of costume in the current target\\n   */\\n  COSTUME: 'costume',\\n  /**\\n   * Name of sound in the current target\\n   */\\n  SOUND: 'sound'\\n};\\nmodule.exports = ArgumentType;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/block-type.js\\\":\\n/*!*********************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/block-type.js ***!\\n  \\\\*********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Types of block\\n * @enum {string}\\n */\\nconst BlockType = {\\n  /**\\n   * Boolean reporter with hexagonal shape\\n   */\\n  BOOLEAN: 'Boolean',\\n  /**\\n   * A button (not an actual block) for some special action, like making a variable\\n   */\\n  BUTTON: 'button',\\n  /**\\n   * A text label (not an actual block) for adding comments or labling blocks\\n   */\\n  LABEL: 'label',\\n  /**\\n   * Command block\\n   */\\n  COMMAND: 'command',\\n  /**\\n   * Specialized command block which may or may not run a child branch\\n   * The thread continues with the next block whether or not a child branch ran.\\n   */\\n  CONDITIONAL: 'conditional',\\n  /**\\n   * Specialized hat block with no implementation function\\n   * This stack only runs if the corresponding event is emitted by other code.\\n   */\\n  EVENT: 'event',\\n  /**\\n   * Hat block which conditionally starts a block stack\\n   */\\n  HAT: 'hat',\\n  /**\\n   * Specialized command block which may or may not run a child branch\\n   * If a child branch runs, the thread evaluates the loop block again.\\n   */\\n  LOOP: 'loop',\\n  /**\\n   * General reporter with numeric or string value\\n   */\\n  REPORTER: 'reporter'\\n};\\nmodule.exports = BlockType;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/extension-worker.js\\\":\\n/*!***************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/extension-worker.js ***!\\n  \\\\***************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(global) {/* eslint-env worker */\\n\\nconst ScratchCommon = __webpack_require__(/*! ./tw-extension-api-common */ \\\"./node_modules/scratch-vm/src/extension-support/tw-extension-api-common.js\\\");\\nconst dispatch = __webpack_require__(/*! ../dispatch/worker-dispatch */ \\\"./node_modules/scratch-vm/src/dispatch/worker-dispatch.js\\\");\\nconst log = __webpack_require__(/*! ../util/log */ \\\"./node_modules/scratch-vm/src/util/log.js\\\");\\nconst {\\n  isWorker\\n} = __webpack_require__(/*! ./tw-extension-worker-context */ \\\"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\\\");\\nconst createTranslate = __webpack_require__(/*! ./tw-l10n */ \\\"./node_modules/scratch-vm/src/extension-support/tw-l10n.js\\\");\\nconst translate = createTranslate(null);\\nconst loadScripts = url => {\\n  if (isWorker) {\\n    importScripts(url);\\n  } else {\\n    return new Promise((resolve, reject) => {\\n      const script = document.createElement('script');\\n      script.onload = () => resolve();\\n      script.onerror = () => {\\n        reject(new Error(\\\"Error in sandboxed script: \\\".concat(url, \\\". Check the console for more information.\\\")));\\n      };\\n      script.src = url;\\n      document.body.appendChild(script);\\n    });\\n  }\\n};\\nclass ExtensionWorker {\\n  constructor() {\\n    this.nextExtensionId = 0;\\n    this.initialRegistrations = [];\\n    this.firstRegistrationPromise = new Promise(resolve => {\\n      this.firstRegistrationCallback = resolve;\\n    });\\n    dispatch.waitForConnection.then(() => {\\n      dispatch.call('extensions', 'allocateWorker').then(async x => {\\n        const [id, extension] = x;\\n        this.workerId = id;\\n        try {\\n          await loadScripts(extension);\\n          await this.firstRegistrationPromise;\\n          const initialRegistrations = this.initialRegistrations;\\n          this.initialRegistrations = null;\\n          Promise.all(initialRegistrations).then(() => dispatch.call('extensions', 'onWorkerInit', id));\\n        } catch (e) {\\n          log.error(e);\\n          dispatch.call('extensions', 'onWorkerInit', id, \\\"\\\".concat(e));\\n        }\\n      });\\n    });\\n    this.extensions = [];\\n  }\\n  register(extensionObject) {\\n    const extensionId = this.nextExtensionId++;\\n    this.extensions.push(extensionObject);\\n    const serviceName = \\\"extension.\\\".concat(this.workerId, \\\".\\\").concat(extensionId);\\n    const promise = dispatch.setService(serviceName, extensionObject).then(() => dispatch.call('extensions', 'registerExtensionService', serviceName));\\n    if (this.initialRegistrations) {\\n      this.firstRegistrationCallback();\\n      this.initialRegistrations.push(promise);\\n    }\\n    return promise;\\n  }\\n}\\nglobal.Scratch = global.Scratch || {};\\nObject.assign(global.Scratch, ScratchCommon, {\\n  canFetch: () => Promise.resolve(true),\\n  fetch: function (_fetch) {\\n    function fetch(_x, _x2) {\\n      return _fetch.apply(this, arguments);\\n    }\\n    fetch.toString = function () {\\n      return _fetch.toString();\\n    };\\n    return fetch;\\n  }((url, options) => fetch(url, options)),\\n  canOpenWindow: () => Promise.resolve(false),\\n  openWindow: () => Promise.reject(new Error('Scratch.openWindow not supported in sandboxed extensions')),\\n  canRedirect: () => Promise.resolve(false),\\n  redirect: () => Promise.reject(new Error('Scratch.redirect not supported in sandboxed extensions')),\\n  canRecordAudio: () => Promise.resolve(false),\\n  canRecordVideo: () => Promise.resolve(false),\\n  canReadClipboard: () => Promise.resolve(false),\\n  canNotify: () => Promise.resolve(false),\\n  translate\\n});\\n\\n/**\\n * Expose only specific parts of the worker to extensions.\\n */\\nconst extensionWorker = new ExtensionWorker();\\nglobal.Scratch.extensions = {\\n  register: extensionWorker.register.bind(extensionWorker)\\n};\\nglobal.ScratchExtensions = __webpack_require__(/*! ./tw-scratchx-compatibility-layer */ \\\"./node_modules/scratch-vm/src/extension-support/tw-scratchx-compatibility-layer.js\\\");\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \\\"./node_modules/webpack/buildin/global.js\\\")))\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/target-type.js\\\":\\n/*!**********************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/target-type.js ***!\\n  \\\\**********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Default types of Target supported by the VM\\n * @enum {string}\\n */\\nconst TargetType = {\\n  /**\\n   * Rendered target which can move, change costumes, etc.\\n   */\\n  SPRITE: 'sprite',\\n  /**\\n   * Rendered target which cannot move but can change backdrops\\n   */\\n  STAGE: 'stage'\\n};\\nmodule.exports = TargetType;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/tw-extension-api-common.js\\\":\\n/*!**********************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-extension-api-common.js ***!\\n  \\\\**********************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nconst ArgumentType = __webpack_require__(/*! ./argument-type */ \\\"./node_modules/scratch-vm/src/extension-support/argument-type.js\\\");\\nconst BlockType = __webpack_require__(/*! ./block-type */ \\\"./node_modules/scratch-vm/src/extension-support/block-type.js\\\");\\nconst TargetType = __webpack_require__(/*! ./target-type */ \\\"./node_modules/scratch-vm/src/extension-support/target-type.js\\\");\\nconst Cast = __webpack_require__(/*! ../util/cast */ \\\"./node_modules/scratch-vm/src/util/cast.js\\\");\\nconst Scratch = {\\n  ArgumentType,\\n  BlockType,\\n  TargetType,\\n  Cast\\n};\\nmodule.exports = Scratch;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js\\\":\\n/*!**************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-extension-worker-context.js ***!\\n  \\\\**************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\nmodule.exports = {\\n  isWorker: true,\\n  // centralDispatchService is the object to call postMessage() on to send a message to parent.\\n  centralDispatchService: self\\n};\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/tw-jquery-shim.js\\\":\\n/*!*************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-jquery-shim.js ***!\\n  \\\\*************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(global) {/**\\n * @fileoverview\\n * Many ScratchX extensions require jQuery to do things like loading scripts and making requests.\\n * The real jQuery is pretty large and we'd rather not bring in everything, so this file reimplements\\n * small stubs of a few jQuery methods.\\n * It's just supposed to be enough to make existing ScratchX extensions work, nothing more.\\n */\\n\\nconst log = __webpack_require__(/*! ../util/log */ \\\"./node_modules/scratch-vm/src/util/log.js\\\");\\nconst jQuery = () => {\\n  throw new Error('Not implemented');\\n};\\njQuery.getScript = (src, callback) => {\\n  const script = document.createElement('script');\\n  script.src = src;\\n  if (callback) {\\n    // We don't implement callback arguments.\\n    script.onload = () => callback();\\n  }\\n  document.body.appendChild(script);\\n};\\n\\n/**\\n * @param {Record<string, any>|undefined} obj\\n * @returns {URLSearchParams}\\n */\\nconst objectToQueryString = obj => {\\n  const params = new URLSearchParams();\\n  if (obj) {\\n    for (const key of Object.keys(obj)) {\\n      params.set(key, obj[key]);\\n    }\\n  }\\n  return params;\\n};\\nlet jsonpCallback = 0;\\njQuery.ajax = async (arg1, arg2) => {\\n  let options = {};\\n  if (arg1 && arg2) {\\n    options = arg2;\\n    options.url = arg1;\\n  } else if (arg1) {\\n    options = arg1;\\n  }\\n  const urlParameters = objectToQueryString(options.data);\\n  const getFinalURL = () => {\\n    const query = urlParameters.toString();\\n    let url = options.url;\\n    if (query) {\\n      url += \\\"?\\\".concat(query);\\n    }\\n    // Forcibly upgrade all HTTP requests to HTTPS so that they don't error on HTTPS sites\\n    // All the extensions we care about work fine with this\\n    if (url.startsWith('http://')) {\\n      url = url.replace('http://', 'https://');\\n    }\\n    return url;\\n  };\\n  const successCallback = result => {\\n    if (options.success) {\\n      options.success(result);\\n    }\\n  };\\n  const errorCallback = error => {\\n    log.error(error);\\n    if (options.error) {\\n      // The error object we provide here might not match what jQuery provides but it's enough to\\n      // prevent extensions from throwing errors trying to access properties.\\n      options.error(error);\\n    }\\n  };\\n  try {\\n    if (options.dataType === 'jsonp') {\\n      const callbackName = \\\"_jsonp_callback\\\".concat(jsonpCallback++);\\n      global[callbackName] = data => {\\n        delete global[callbackName];\\n        successCallback(data);\\n      };\\n      const callbackParameterName = options.jsonp || 'callback';\\n      urlParameters.set(callbackParameterName, callbackName);\\n      jQuery.getScript(getFinalURL());\\n      return;\\n    }\\n    if (options.dataType === 'script') {\\n      jQuery.getScript(getFinalURL(), successCallback);\\n      return;\\n    }\\n    const res = await fetch(getFinalURL(), {\\n      headers: options.headers\\n    });\\n    // dataType defaults to \\\"Intelligent Guess (xml, json, script, or html)\\\"\\n    // It happens that all the ScratchX extensions we care about either set dataType to \\\"json\\\" or\\n    // leave it blank and implicitly request JSON, so this works good enough for now.\\n    successCallback(await res.json());\\n  } catch (e) {\\n    errorCallback(e);\\n  }\\n};\\nmodule.exports = jQuery;\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \\\"./node_modules/webpack/buildin/global.js\\\")))\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/tw-l10n.js\\\":\\n/*!******************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-l10n.js ***!\\n  \\\\******************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nconst formatMessage = __webpack_require__(/*! format-message */ \\\"./node_modules/scratch-vm/node_modules/format-message/index.js\\\");\\n\\n/**\\n * @param {VM|null} vm\\n * @returns {object}\\n */\\nconst createTranslate = vm => {\\n  const namespace = formatMessage.namespace();\\n  const translate = (message, args) => {\\n    if (message && typeof message === 'object') {\\n      // already in the expected format\\n    } else if (typeof message === 'string') {\\n      message = {\\n        default: message\\n      };\\n    } else {\\n      throw new Error('unsupported data type in translate()');\\n    }\\n    return namespace(message, args);\\n  };\\n  const generateId = defaultMessage => \\\"_\\\".concat(defaultMessage);\\n  const getLocale = () => {\\n    if (vm) return vm.getLocale();\\n    if (typeof navigator !== 'undefined') return navigator.language;\\n    return 'en';\\n  };\\n  let storedTranslations = {};\\n  translate.setup = newTranslations => {\\n    if (newTranslations) {\\n      storedTranslations = newTranslations;\\n    }\\n    namespace.setup({\\n      locale: getLocale(),\\n      missingTranslation: 'ignore',\\n      generateId,\\n      translations: storedTranslations\\n    });\\n  };\\n  translate.setup({});\\n  if (vm) {\\n    vm.on('LOCALE_CHANGED', () => {\\n      translate.setup(null);\\n    });\\n  }\\n  return translate;\\n};\\nmodule.exports = createTranslate;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/tw-scratchx-compatibility-layer.js\\\":\\n/*!******************************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-scratchx-compatibility-layer.js ***!\\n  \\\\******************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n// ScratchX API Documentation: https://github.com/LLK/scratchx/wiki/\\n\\n// Global Scratch API from extension-worker.js\\n/* globals Scratch */\\n\\nconst ArgumentType = __webpack_require__(/*! ./argument-type */ \\\"./node_modules/scratch-vm/src/extension-support/argument-type.js\\\");\\nconst BlockType = __webpack_require__(/*! ./block-type */ \\\"./node_modules/scratch-vm/src/extension-support/block-type.js\\\");\\nconst {\\n  argumentIndexToId,\\n  generateExtensionId\\n} = __webpack_require__(/*! ./tw-scratchx-utilities */ \\\"./node_modules/scratch-vm/src/extension-support/tw-scratchx-utilities.js\\\");\\n\\n/**\\n * @typedef ScratchXDescriptor\\n * @property {unknown[][]} blocks\\n * @property {Record<string, unknown[]>} [menus]\\n * @property {string} [url]\\n * @property {string} [displayName]\\n */\\n\\n/**\\n * @typedef ScratchXStatus\\n * @property {0|1|2} status 0 is red/error, 1 is yellow/not ready, 2 is green/ready\\n * @property {string} msg\\n */\\n\\nconst parseScratchXBlockType = type => {\\n  if (type === '' || type === ' ' || type === 'w') {\\n    return {\\n      type: BlockType.COMMAND,\\n      async: type === 'w'\\n    };\\n  }\\n  if (type === 'r' || type === 'R') {\\n    return {\\n      type: BlockType.REPORTER,\\n      async: type === 'R'\\n    };\\n  }\\n  if (type === 'b') {\\n    return {\\n      type: BlockType.BOOLEAN,\\n      // ScratchX docs don't seem to mention boolean reporters that wait\\n      async: false\\n    };\\n  }\\n  if (type === 'h') {\\n    return {\\n      type: BlockType.HAT,\\n      async: false\\n    };\\n  }\\n  throw new Error(\\\"Unknown ScratchX block type: \\\".concat(type));\\n};\\nconst isScratchCompatibleValue = v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean';\\n\\n/**\\n * @param {string} argument ScratchX argument with leading % removed.\\n * @param {unknown} defaultValue Default value, if any\\n */\\nconst parseScratchXArgument = (argument, defaultValue) => {\\n  const result = {};\\n  const hasDefaultValue = isScratchCompatibleValue(defaultValue);\\n  if (hasDefaultValue) {\\n    result.defaultValue = defaultValue;\\n  }\\n  // TODO: ScratchX docs don't mention support for boolean arguments?\\n  if (argument === 's') {\\n    result.type = ArgumentType.STRING;\\n    if (!hasDefaultValue) {\\n      result.defaultValue = '';\\n    }\\n  } else if (argument === 'n') {\\n    result.type = ArgumentType.NUMBER;\\n    if (!hasDefaultValue) {\\n      result.defaultValue = 0;\\n    }\\n  } else if (argument[0] === 'm') {\\n    result.type = ArgumentType.STRING;\\n    const split = argument.split(/\\\\.|:/);\\n    const menuName = split[1];\\n    result.menu = menuName;\\n  } else {\\n    throw new Error(\\\"Unknown ScratchX argument type: \\\".concat(argument));\\n  }\\n  return result;\\n};\\nconst wrapScratchXFunction = (originalFunction, argumentCount, async) => args => {\\n  // Convert Scratch 3's argument object to an argument list expected by ScratchX\\n  const argumentList = [];\\n  for (let i = 0; i < argumentCount; i++) {\\n    argumentList.push(args[argumentIndexToId(i)]);\\n  }\\n  if (async) {\\n    return new Promise(resolve => {\\n      originalFunction(...argumentList, resolve);\\n    });\\n  }\\n  return originalFunction(...argumentList);\\n};\\n\\n/**\\n * @param {string} name\\n * @param {ScratchXDescriptor} descriptor\\n * @param {Record<string, () => unknown>} functions\\n */\\nconst convert = (name, descriptor, functions) => {\\n  const extensionId = generateExtensionId(name);\\n  const info = {\\n    id: extensionId,\\n    name: descriptor.displayName || name,\\n    blocks: [],\\n    color1: '#4a4a5e',\\n    color2: '#31323f',\\n    color3: '#191a21'\\n  };\\n  const scratch3Extension = {\\n    getInfo: () => info,\\n    _getStatus: functions._getStatus\\n  };\\n  if (descriptor.url) {\\n    info.docsURI = descriptor.url;\\n  }\\n  for (const blockDescriptor of descriptor.blocks) {\\n    if (blockDescriptor.length === 1) {\\n      // Separator\\n      info.blocks.push('---');\\n      continue;\\n    }\\n    const scratchXBlockType = blockDescriptor[0];\\n    const blockText = blockDescriptor[1];\\n    const functionName = blockDescriptor[2];\\n    const defaultArgumentValues = blockDescriptor.slice(3);\\n    let scratchText = '';\\n    const argumentInfo = [];\\n    const blockTextParts = blockText.split(/%([\\\\w.:]+)/g);\\n    for (let i = 0; i < blockTextParts.length; i++) {\\n      const part = blockTextParts[i];\\n      const isArgument = i % 2 === 1;\\n      if (isArgument) {\\n        parseScratchXArgument(part);\\n        const argumentIndex = Math.floor(i / 2).toString();\\n        const argumentDefaultValue = defaultArgumentValues[argumentIndex];\\n        const argumentId = argumentIndexToId(argumentIndex);\\n        argumentInfo[argumentId] = parseScratchXArgument(part, argumentDefaultValue);\\n        scratchText += \\\"[\\\".concat(argumentId, \\\"]\\\");\\n      } else {\\n        scratchText += part;\\n      }\\n    }\\n    const scratch3BlockType = parseScratchXBlockType(scratchXBlockType);\\n    const blockInfo = {\\n      opcode: functionName,\\n      blockType: scratch3BlockType.type,\\n      text: scratchText,\\n      arguments: argumentInfo\\n    };\\n    info.blocks.push(blockInfo);\\n    const originalFunction = functions[functionName];\\n    const argumentCount = argumentInfo.length;\\n    scratch3Extension[functionName] = wrapScratchXFunction(originalFunction, argumentCount, scratch3BlockType.async);\\n  }\\n  const menus = descriptor.menus;\\n  if (menus) {\\n    const scratch3Menus = {};\\n    for (const menuName of Object.keys(menus) || {}) {\\n      const menuItems = menus[menuName];\\n      const menuInfo = {\\n        items: menuItems\\n      };\\n      scratch3Menus[menuName] = menuInfo;\\n    }\\n    info.menus = scratch3Menus;\\n  }\\n  return scratch3Extension;\\n};\\nconst extensionNameToExtension = new Map();\\nconst register = (name, descriptor, functions) => {\\n  const scratch3Extension = convert(name, descriptor, functions);\\n  extensionNameToExtension.set(name, scratch3Extension);\\n  Scratch.extensions.register(scratch3Extension);\\n};\\n\\n/**\\n * @param {string} extensionName\\n * @returns {ScratchXStatus}\\n */\\nconst getStatus = extensionName => {\\n  const extension = extensionNameToExtension.get(extensionName);\\n  if (extension) {\\n    return extension._getStatus();\\n  }\\n  return {\\n    status: 0,\\n    msg: 'does not exist'\\n  };\\n};\\nmodule.exports = {\\n  register,\\n  getStatus,\\n  // For tests\\n  convert\\n};\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/extension-support/tw-scratchx-utilities.js\\\":\\n/*!********************************************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/extension-support/tw-scratchx-utilities.js ***!\\n  \\\\********************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\n/**\\n * @fileoverview\\n * General ScratchX-related utilities used in multiple places.\\n * Changing these functions may break projects.\\n */\\n\\n/**\\n * @param {string} scratchXName\\n * @returns {string}\\n */\\nconst generateExtensionId = scratchXName => {\\n  const sanitizedName = scratchXName.replace(/[^a-z0-9]/gi, '').toLowerCase();\\n  return \\\"sbx\\\".concat(sanitizedName);\\n};\\n\\n/**\\n * @param {number} i 0-indexed index of argument in list\\n * @returns {string} Scratch 3 argument name\\n */\\nconst argumentIndexToId = i => i.toString();\\nmodule.exports = {\\n  generateExtensionId,\\n  argumentIndexToId\\n};\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/util/cast.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/util/cast.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nconst Color = __webpack_require__(/*! ../util/color */ \\\"./node_modules/scratch-vm/src/util/color.js\\\");\\n\\n/**\\n * @fileoverview\\n * Utilities for casting and comparing Scratch data-types.\\n * Scratch behaves slightly differently from JavaScript in many respects,\\n * and these differences should be encapsulated below.\\n * For example, in Scratch, add(1, join(\\\"hello\\\", world\\\")) -> 1.\\n * This is because \\\"hello world\\\" is cast to 0.\\n * In JavaScript, 1 + Number(\\\"hello\\\" + \\\"world\\\") would give you NaN.\\n * Use when coercing a value before computation.\\n */\\n\\n/**\\n * Used internally by compare()\\n * @param {*} val A value that evaluates to 0 in JS string-to-number conversation such as empty string, 0, or tab.\\n * @returns {boolean} True if the value should not be treated as the number zero.\\n */\\nconst isNotActuallyZero = val => {\\n  if (typeof val !== 'string') return false;\\n  for (let i = 0; i < val.length; i++) {\\n    const code = val.charCodeAt(i);\\n    // '0'.charCodeAt(0) === 48\\n    // '\\\\t'.charCodeAt(0) === 9\\n    // We include tab for compatibility with scratch-www's broken trim() polyfill.\\n    // https://github.com/TurboWarp/scratch-vm/issues/115\\n    // https://scratch.mit.edu/projects/788261699/\\n    if (code === 48 || code === 9) {\\n      return false;\\n    }\\n  }\\n  return true;\\n};\\nclass Cast {\\n  /**\\n   * Scratch cast to number.\\n   * Treats NaN as 0.\\n   * In Scratch 2.0, this is captured by `interp.numArg.`\\n   * @param {*} value Value to cast to number.\\n   * @return {number} The Scratch-casted number value.\\n   */\\n  static toNumber(value) {\\n    // If value is already a number we don't need to coerce it with\\n    // Number().\\n    if (typeof value === 'number') {\\n      // Scratch treats NaN as 0, when needed as a number.\\n      // E.g., 0 + NaN -> 0.\\n      if (Number.isNaN(value)) {\\n        return 0;\\n      }\\n      return value;\\n    }\\n    const n = Number(value);\\n    if (Number.isNaN(n)) {\\n      // Scratch treats NaN as 0, when needed as a number.\\n      // E.g., 0 + NaN -> 0.\\n      return 0;\\n    }\\n    return n;\\n  }\\n\\n  /**\\n   * Scratch cast to boolean.\\n   * In Scratch 2.0, this is captured by `interp.boolArg.`\\n   * Treats some string values differently from JavaScript.\\n   * @param {*} value Value to cast to boolean.\\n   * @return {boolean} The Scratch-casted boolean value.\\n   */\\n  static toBoolean(value) {\\n    // Already a boolean?\\n    if (typeof value === 'boolean') {\\n      return value;\\n    }\\n    if (typeof value === 'string') {\\n      // These specific strings are treated as false in Scratch.\\n      if (value === '' || value === '0' || value.toLowerCase() === 'false') {\\n        return false;\\n      }\\n      // All other strings treated as true.\\n      return true;\\n    }\\n    // Coerce other values and numbers.\\n    return Boolean(value);\\n  }\\n\\n  /**\\n   * Scratch cast to string.\\n   * @param {*} value Value to cast to string.\\n   * @return {string} The Scratch-casted string value.\\n   */\\n  static toString(value) {\\n    return String(value);\\n  }\\n\\n  /**\\n   * Cast any Scratch argument to an RGB color array to be used for the renderer.\\n   * @param {*} value Value to convert to RGB color array.\\n   * @return {Array.<number>} [r,g,b], values between 0-255.\\n   */\\n  static toRgbColorList(value) {\\n    const color = Cast.toRgbColorObject(value);\\n    return [color.r, color.g, color.b];\\n  }\\n\\n  /**\\n   * Cast any Scratch argument to an RGB color object to be used for the renderer.\\n   * @param {*} value Value to convert to RGB color object.\\n   * @return {RGBOject} [r,g,b], values between 0-255.\\n   */\\n  static toRgbColorObject(value) {\\n    let color;\\n    if (typeof value === 'string' && value.substring(0, 1) === '#') {\\n      color = Color.hexToRgb(value);\\n\\n      // If the color wasn't *actually* a hex color, cast to black\\n      if (!color) color = {\\n        r: 0,\\n        g: 0,\\n        b: 0,\\n        a: 255\\n      };\\n    } else {\\n      color = Color.decimalToRgb(Cast.toNumber(value));\\n    }\\n    return color;\\n  }\\n\\n  /**\\n   * Determine if a Scratch argument is a white space string (or null / empty).\\n   * @param {*} val value to check.\\n   * @return {boolean} True if the argument is all white spaces or null / empty.\\n   */\\n  static isWhiteSpace(val) {\\n    return val === null || typeof val === 'string' && val.trim().length === 0;\\n  }\\n\\n  /**\\n   * Compare two values, using Scratch cast, case-insensitive string compare, etc.\\n   * In Scratch 2.0, this is captured by `interp.compare.`\\n   * @param {*} v1 First value to compare.\\n   * @param {*} v2 Second value to compare.\\n   * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\\n   */\\n  static compare(v1, v2) {\\n    let n1 = Number(v1);\\n    let n2 = Number(v2);\\n    if (n1 === 0 && isNotActuallyZero(v1)) {\\n      n1 = NaN;\\n    } else if (n2 === 0 && isNotActuallyZero(v2)) {\\n      n2 = NaN;\\n    }\\n    if (isNaN(n1) || isNaN(n2)) {\\n      // At least one argument can't be converted to a number.\\n      // Scratch compares strings as case insensitive.\\n      const s1 = String(v1).toLowerCase();\\n      const s2 = String(v2).toLowerCase();\\n      if (s1 < s2) {\\n        return -1;\\n      } else if (s1 > s2) {\\n        return 1;\\n      }\\n      return 0;\\n    }\\n    // Handle the special case of Infinity\\n    if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {\\n      return 0;\\n    }\\n    // Compare as numbers.\\n    return n1 - n2;\\n  }\\n\\n  /**\\n   * Determine if a Scratch argument number represents a round integer.\\n   * @param {*} val Value to check.\\n   * @return {boolean} True if number looks like an integer.\\n   */\\n  static isInt(val) {\\n    // Values that are already numbers.\\n    if (typeof val === 'number') {\\n      if (isNaN(val)) {\\n        // NaN is considered an integer.\\n        return true;\\n      }\\n      // True if it's \\\"round\\\" (e.g., 2.0 and 2).\\n      return val === Math.floor(val);\\n    } else if (typeof val === 'boolean') {\\n      // `True` and `false` always represent integer after Scratch cast.\\n      return true;\\n    } else if (typeof val === 'string') {\\n      // If it contains a decimal point, don't consider it an int.\\n      return val.indexOf('.') < 0;\\n    }\\n    return false;\\n  }\\n  static get LIST_INVALID() {\\n    return 'INVALID';\\n  }\\n  static get LIST_ALL() {\\n    return 'ALL';\\n  }\\n\\n  /**\\n   * Compute a 1-based index into a list, based on a Scratch argument.\\n   * Two special cases may be returned:\\n   * LIST_ALL: if the block is referring to all of the items in the list.\\n   * LIST_INVALID: if the index was invalid in any way.\\n   * @param {*} index Scratch arg, including 1-based numbers or special cases.\\n   * @param {number} length Length of the list.\\n   * @param {boolean} acceptAll Whether it should accept \\\"all\\\" or not.\\n   * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\\n   */\\n  static toListIndex(index, length, acceptAll) {\\n    if (typeof index !== 'number') {\\n      if (index === 'all') {\\n        return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\\n      }\\n      if (index === 'last') {\\n        if (length > 0) {\\n          return length;\\n        }\\n        return Cast.LIST_INVALID;\\n      } else if (index === 'random' || index === 'any') {\\n        if (length > 0) {\\n          return 1 + Math.floor(Math.random() * length);\\n        }\\n        return Cast.LIST_INVALID;\\n      }\\n    }\\n    index = Math.floor(Cast.toNumber(index));\\n    if (index < 1 || index > length) {\\n      return Cast.LIST_INVALID;\\n    }\\n    return index;\\n  }\\n}\\nmodule.exports = Cast;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/util/color.js\\\":\\n/*!***************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/util/color.js ***!\\n  \\\\***************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\nclass Color {\\n  /**\\n   * @typedef {object} RGBObject - An object representing a color in RGB format.\\n   * @property {number} r - the red component, in the range [0, 255].\\n   * @property {number} g - the green component, in the range [0, 255].\\n   * @property {number} b - the blue component, in the range [0, 255].\\n   */\\n\\n  /**\\n   * @typedef {object} HSVObject - An object representing a color in HSV format.\\n   * @property {number} h - hue, in the range [0-359).\\n   * @property {number} s - saturation, in the range [0,1].\\n   * @property {number} v - value, in the range [0,1].\\n   */\\n\\n  /** @type {RGBObject} */\\n  static get RGB_BLACK() {\\n    return {\\n      r: 0,\\n      g: 0,\\n      b: 0\\n    };\\n  }\\n\\n  /** @type {RGBObject} */\\n  static get RGB_WHITE() {\\n    return {\\n      r: 255,\\n      g: 255,\\n      b: 255\\n    };\\n  }\\n\\n  /**\\n   * Convert a Scratch decimal color to a hex string, #RRGGBB.\\n   * @param {number} decimal RGB color as a decimal.\\n   * @return {string} RGB color as #RRGGBB hex string.\\n   */\\n  static decimalToHex(decimal) {\\n    if (decimal < 0) {\\n      decimal += 0xFFFFFF + 1;\\n    }\\n    let hex = Number(decimal).toString(16);\\n    hex = \\\"#\\\".concat('000000'.substr(0, 6 - hex.length)).concat(hex);\\n    return hex;\\n  }\\n\\n  /**\\n   * Convert a Scratch decimal color to an RGB color object.\\n   * @param {number} decimal RGB color as decimal.\\n   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\\n   */\\n  static decimalToRgb(decimal) {\\n    const a = decimal >> 24 & 0xFF;\\n    const r = decimal >> 16 & 0xFF;\\n    const g = decimal >> 8 & 0xFF;\\n    const b = decimal & 0xFF;\\n    return {\\n      r: r,\\n      g: g,\\n      b: b,\\n      a: a > 0 ? a : 255\\n    };\\n  }\\n\\n  /**\\n   * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\\n   * @param {!string} hex Hex representation of the color.\\n   * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\\n   */\\n  static hexToRgb(hex) {\\n    if (hex.startsWith('#')) {\\n      hex = hex.substring(1);\\n    }\\n    const parsed = parseInt(hex, 16);\\n    if (isNaN(parsed)) {\\n      return null;\\n    }\\n    if (hex.length === 6) {\\n      return {\\n        r: parsed >> 16 & 0xff,\\n        g: parsed >> 8 & 0xff,\\n        b: parsed & 0xff\\n      };\\n    } else if (hex.length === 3) {\\n      const r = parsed >> 8 & 0xf;\\n      const g = parsed >> 4 & 0xf;\\n      const b = parsed & 0xf;\\n      return {\\n        r: r << 4 | r,\\n        g: g << 4 | g,\\n        b: b << 4 | b\\n      };\\n    }\\n    return null;\\n  }\\n\\n  /**\\n   * Convert an RGB color object to a hex color.\\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\\n   * @return {!string} Hex representation of the color.\\n   */\\n  static rgbToHex(rgb) {\\n    return Color.decimalToHex(Color.rgbToDecimal(rgb));\\n  }\\n\\n  /**\\n   * Convert an RGB color object to a Scratch decimal color.\\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\\n   * @return {!number} Number representing the color.\\n   */\\n  static rgbToDecimal(rgb) {\\n    return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\\n  }\\n\\n  /**\\n  * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\\n  * @param {!string} hex Hex representation of the color.\\n  * @return {!number} Number representing the color.\\n  */\\n  static hexToDecimal(hex) {\\n    return Color.rgbToDecimal(Color.hexToRgb(hex));\\n  }\\n\\n  /**\\n   * Convert an HSV color to RGB format.\\n   * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\\n   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\\n   */\\n  static hsvToRgb(hsv) {\\n    let h = hsv.h % 360;\\n    if (h < 0) h += 360;\\n    const s = Math.max(0, Math.min(hsv.s, 1));\\n    const v = Math.max(0, Math.min(hsv.v, 1));\\n    const i = Math.floor(h / 60);\\n    const f = h / 60 - i;\\n    const p = v * (1 - s);\\n    const q = v * (1 - s * f);\\n    const t = v * (1 - s * (1 - f));\\n    let r;\\n    let g;\\n    let b;\\n    switch (i) {\\n      default:\\n      case 0:\\n        r = v;\\n        g = t;\\n        b = p;\\n        break;\\n      case 1:\\n        r = q;\\n        g = v;\\n        b = p;\\n        break;\\n      case 2:\\n        r = p;\\n        g = v;\\n        b = t;\\n        break;\\n      case 3:\\n        r = p;\\n        g = q;\\n        b = v;\\n        break;\\n      case 4:\\n        r = t;\\n        g = p;\\n        b = v;\\n        break;\\n      case 5:\\n        r = v;\\n        g = p;\\n        b = q;\\n        break;\\n    }\\n    return {\\n      r: Math.floor(r * 255),\\n      g: Math.floor(g * 255),\\n      b: Math.floor(b * 255)\\n    };\\n  }\\n\\n  /**\\n   * Convert an RGB color to HSV format.\\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\\n   * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\\n   */\\n  static rgbToHsv(rgb) {\\n    const r = rgb.r / 255;\\n    const g = rgb.g / 255;\\n    const b = rgb.b / 255;\\n    const x = Math.min(Math.min(r, g), b);\\n    const v = Math.max(Math.max(r, g), b);\\n\\n    // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\\n    let h = 0;\\n    let s = 0;\\n    if (x !== v) {\\n      const f = r === x ? g - b : g === x ? b - r : r - g;\\n      const i = r === x ? 3 : g === x ? 5 : 1;\\n      h = (i - f / (v - x)) * 60 % 360;\\n      s = (v - x) / v;\\n    }\\n    return {\\n      h: h,\\n      s: s,\\n      v: v\\n    };\\n  }\\n\\n  /**\\n   * Linear interpolation between rgb0 and rgb1.\\n   * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\\n   * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\\n   * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\\n   * @return {RGBObject} the interpolated color.\\n   */\\n  static mixRgb(rgb0, rgb1, fraction1) {\\n    if (fraction1 <= 0) return rgb0;\\n    if (fraction1 >= 1) return rgb1;\\n    const fraction0 = 1 - fraction1;\\n    return {\\n      r: fraction0 * rgb0.r + fraction1 * rgb1.r,\\n      g: fraction0 * rgb0.g + fraction1 * rgb1.g,\\n      b: fraction0 * rgb0.b + fraction1 * rgb1.b\\n    };\\n  }\\n}\\nmodule.exports = Color;\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/scratch-vm/src/util/log.js\\\":\\n/*!*************************************************!*\\\\\\n  !*** ./node_modules/scratch-vm/src/util/log.js ***!\\n  \\\\*************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nconst minilog = __webpack_require__(/*! minilog */ \\\"./node_modules/scratch-vm/node_modules/minilog/lib/web/index.js\\\");\\nminilog.enable();\\nmodule.exports = minilog('vm');\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/webpack/buildin/global.js\\\":\\n/*!***********************************!*\\\\\\n  !*** (webpack)/buildin/global.js ***!\\n  \\\\***********************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\nvar g;\\n\\n// This works in non-strict mode\\ng = (function() {\\n\\treturn this;\\n})();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || new Function(\\\"return this\\\")();\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \\\"object\\\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it's\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;\\n\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=extension worker.js.map\";"],"mappings":";;;;;;;;;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AC/FA;;;;A","sourceRoot":""}